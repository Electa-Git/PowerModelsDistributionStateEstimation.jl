<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Input Data Format · PowerModelsDistributionStateEstimation.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">PowerModelsDistributionStateEstimation.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../quickguide/">Getting Started</a></li><li class="is-active"><a class="tocitem" href>Input Data Format</a><ul class="internal"><li><a class="tocitem" href="#Network-Data-Input-1"><span>Network Data Input</span></a></li><li><a class="tocitem" href="#Measurement-Data-1"><span>Measurement Data</span></a></li><li><a class="tocitem" href="#State-estimation-settings-1"><span>State estimation settings</span></a></li><li><a class="tocitem" href="#Putting-everything-together:-complete-input-data-1"><span>Putting everything together: complete input data</span></a></li></ul></li><li><a class="tocitem" href="../measurements/">Measurements and Conversions</a></li><li><a class="tocitem" href="../se_criteria/">State Estimation Criteria</a></li></ul></li><li><span class="tocitem">Library </span><ul><li><a class="tocitem" href="../formulations/">Power Flow Formulations</a></li><li><a class="tocitem" href="../problems/">Problem Specifications</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Input Data Format</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Input Data Format</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/Electa-Git/PowerModelsDistributionStateEstimation.jl/blob/master/docs/src/input_data_format.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Input-Data-Format-1"><a class="docs-heading-anchor" href="#Input-Data-Format-1">Input Data Format</a><a class="docs-heading-anchor-permalink" href="#Input-Data-Format-1" title="Permalink"></a></h1><p>The data input required by PowerModelsDistributionStateEstimation takes the form of a dictionary and can be subdivided in three parts:</p><ul><li>Network data</li><li>Measurement data</li><li>State estimation settings</li></ul><p>The network data contains all the information relative to the physics of the analyzed network: topology, line impedance, location and specs of loads, generators, etc.. The measurement data contains all the information relative to the (pseudo-)measurements available for that network: number and placement of meters, measured quantities (power, voltage...) and measurement accuracy. The state estimation settings allow the user to choose the type of estimation criterion to be used (e.g., WLS, WLAV,..) and add a weight rescaler. More details on each of the three parts can be found in the following sections of this manual.</p><h2 id="Network-Data-Input-1"><a class="docs-heading-anchor" href="#Network-Data-Input-1">Network Data Input</a><a class="docs-heading-anchor-permalink" href="#Network-Data-Input-1" title="Permalink"></a></h2><p>The network data input of PowerModelsDistributionStateEstimation is based on that of PowerModelsDistribution (PMD). In the versions supported by PowerModelsDistributionStateEstimation, PMD allows for two input data formats:</p><ul><li>The <code>ENGINEERING</code> model (extensively documented <a href="https://lanl-ansi.github.io/PowerModelsDistribution.jl/stable/eng-data-model/">here</a>)</li><li>The <code>MATHEMATICAL</code> model</li></ul><p>The idea behind offering two options is that the <code>ENGINEERING</code> model is quite intuitive and allows a non-developer to easily generate data and use the PMD package as made available. The <code>MATHEMATICAL</code> model allows developers to explore the details of the PMD package and/or add extra information that can be passed as additional input to go beyond the functionalities that are natively offered in PMD. Ultimately, both PMD and PowerModelsDistributionStateEstimation use a <code>MATHEMATICAL</code> model as input for the calculations, but PMD can be provided directly an <code>ENGINEERING</code> model, which is then transformed at runtime. This is not the case in PowerModelsDistributionStateEstimation, which requires measurement data and state estimation settings to perform state estimation calculations. These two take the form of &quot;sub-dictionaries&quot; that need to be appended to a PMD <code>MATHEMATICAL</code> network data model dictionary. If added to the <code>ENGINEERING</code> data model, they will be ignored in the transformation to the <code>MATHEMATICAL</code> model, returning an error. For additional information on the structure of the network data input, the user is referred to the <a href="https://lanl-ansi.github.io/PowerModelsDistribution.jl/stable/">PMD manual</a>. The user can build the network data from scratch, for example writing a native julia parser that builds the dictionary starting from external files. However, to encourage the use and creation of easily reproducible test cases, PMDSE uses the parsing functionalities of PowerModels and PowerModelsDistribution that allow users to directly read network data from the following file formats:</p><ul><li>OpenDSS files (&quot;.dss&quot;),</li><li>Matpower files (&quot;.m&quot;),</li><li>JSON files (&quot;.json&quot;) created from PowerModels.</li></ul><p>Furthermore, within PMDSE the network and load/generation data and parsers of the ENWL dataset are available and easy-to-use, courtesy of Sander Claeys (<a href="https://github.com/sanderclaeys">@sanderclaeys</a>).</p><h3 id="Parsing-OpenDSS-files-1"><a class="docs-heading-anchor" href="#Parsing-OpenDSS-files-1">Parsing OpenDSS files</a><a class="docs-heading-anchor-permalink" href="#Parsing-OpenDSS-files-1" title="Permalink"></a></h3><p>To parse an OpenDSS file into PowerModelsDistribution&#39;s default <code>ENGINEERING</code> format, use the <code>parse_file</code> function:</p><pre><code class="language-julia">eng = PowerModelsDistribution.parse_file(&quot;path/to/file/file_name.dss&quot;)</code></pre><p>To obtain the <code>MATHEMATICAL</code> model it is possible to transform the data model using the <code>transform_data_model</code> function.</p><pre><code class="language-julia">math = PowerModelsDistribution.transform_data_model(eng)</code></pre><p>A small example of OpenDSS network data can be found in PowerModelsDistributionStateEstimation/test/data/extra/networks</p><h3 id="Parsing-ENWL-files-1"><a class="docs-heading-anchor" href="#Parsing-ENWL-files-1">Parsing ENWL files</a><a class="docs-heading-anchor-permalink" href="#Parsing-ENWL-files-1" title="Permalink"></a></h3><p><a href="https://www.enwl.co.uk/zero-carbon/innovation/smaller-projects/low-carbon-networks-fund/low-voltage-network-solutions/">ENWL files</a> are a collection of 25 real low voltage distribution networks (each of the networks&#39; feeders is also individually accessible) and realistic demand/generation profile data, made available by the Electricity North West and The University of Manchester.</p><p>The data is available in OpenDSS-like format in PowerModelsDistributionStateEstimation/test/data/enwl/networks and can be parsed with the PowerModelsDistribution <code>parse_file</code> function. A specific feeder <code>fdr</code> of a network <code>ntw</code> should be parsed to the <code>ENGINEERING</code> model, using:</p><pre><code class="language-julia">eng_data = PowerModelsDistribution.parse_file(PowerModelsDistributionStateEstimation.get_enwl_dss_path(ntw,fdr),data_model=PowerModelsDistribution.ENGINEERING)</code></pre><p>All feeders are featured with a detailed transformer model. It might be convenient or necessary to drop the transformer model and define the source bus as a slack bus: this (slightly) improves tractability and in low voltage power flow and state estimation studies, the exact substation model is often not taken into account. The removal should happen at the <code>ENGINEERING</code> data stage:</p><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistributionStateEstimation.rm_enwl_transformer!-Tuple{Any}" href="#PowerModelsDistributionStateEstimation.rm_enwl_transformer!-Tuple{Any}"><code>PowerModelsDistributionStateEstimation.rm_enwl_transformer!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">rm_enwl_transformer!(data_eng)</code></pre><p>This function removes the transformer from a parsed ENWL <code>ENGINEERING</code> data file.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Electa-Git/PowerModelsDistributionStateEstimation.jl/blob/14f53ef1867945033576bc36b1e346644120ad05/src/io/network_parser.jl#L85-L89">source</a></section></article><p>The ENWL feeders feature a high number of buses that are only used to interpolate the topology layout (i.e., where the cables are) but that host no device. Function <code>reduce_enwl_lines_eng!</code> is included specifically to simplify the data and remove the nodes and lines in excess in order to (considerably) improve tractability. It is highly recommended to use it. The resulting feeder is equivalent to the original one in terms of physical properties, and the calculation results are the same. The function can be applied both to an ENGINEERING and a MATHEMATICAL data model.</p><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistributionStateEstimation.reduce_enwl_lines_eng!-Tuple{Any}" href="#PowerModelsDistributionStateEstimation.reduce_enwl_lines_eng!-Tuple{Any}"><code>PowerModelsDistributionStateEstimation.reduce_enwl_lines_eng!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">reduce_enwl_lines_eng!(data_eng)</code></pre><p>This function removes all trailing lines from a parsed ENWL <code>ENGINEERING</code> data file.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Electa-Git/PowerModelsDistributionStateEstimation.jl/blob/14f53ef1867945033576bc36b1e346644120ad05/src/io/network_parser.jl#L111-L116">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistributionStateEstimation.reduce_enwl_lines_math!-Tuple{Any}" href="#PowerModelsDistributionStateEstimation.reduce_enwl_lines_math!-Tuple{Any}"><code>PowerModelsDistributionStateEstimation.reduce_enwl_lines_math!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">reduce_enwl_lines_math!(data_math)</code></pre><p>This function removes all trailing lines from a parsed ENWL <code>MATHEMATICAL</code> data file.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Electa-Git/PowerModelsDistributionStateEstimation.jl/blob/14f53ef1867945033576bc36b1e346644120ad05/src/io/network_parser.jl#L229-L234">source</a></section></article><p>Contrary to &quot;regular&quot; OpenDSS files, load profile information needs to be parsed and added to the ENWL feeder ENGINEERING data obtained so far. This is accomplished using the <code>insert_profiles!</code> function:</p><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistributionStateEstimation.insert_profiles!-NTuple{4, Any}" href="#PowerModelsDistributionStateEstimation.insert_profiles!-NTuple{4, Any}"><code>PowerModelsDistributionStateEstimation.insert_profiles!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">insert_profiles!(data, season, devices, pfs; t=missing, useactual=true)</code></pre><p>This function adds the load profiles to the parsed ENWL ENGINEERING data <code>data</code>.</p><p><strong>Arguments</strong></p><ul><li>data: ENGINEERING data model of the feeder</li><li>season: <code>&quot;summer&quot;</code>, <code>&quot;winter&quot;</code></li><li>devices: <code>&quot;load&quot;</code>, <code>&quot;pv&quot;</code>, <code>&quot;ev&quot;</code>, <code>&quot;ehp&quot;</code>, <code>&quot;uchp&quot;</code></li><li>pfs: power factor of the devices</li><li>t: time-step</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; data = parse_file(get_enwl_dss_path(10, 1))
julia&gt; insert_profiles!(data, &quot;summer&quot;, [&quot;load&quot;, &quot;pv&quot;], [0.95, 0.90], t = 144)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Electa-Git/PowerModelsDistributionStateEstimation.jl/blob/14f53ef1867945033576bc36b1e346644120ad05/src/io/network_parser.jl#L40-L56">source</a></section></article><p>The ENWL data set features a number of low-carbon technologies profiles: electric vehicles (EV), electric heat pumps (EHP), micro-CHP (uCHP), photovoltaic panels (PV). &quot;load&quot; indicates the &quot;traditional&quot; residential load.</p><h3 id="Parsing-Matpower-files-1"><a class="docs-heading-anchor" href="#Parsing-Matpower-files-1">Parsing Matpower files</a><a class="docs-heading-anchor-permalink" href="#Parsing-Matpower-files-1" title="Permalink"></a></h3><p>Matpower file can be parsed with PowerModels&#39; function: <code>parse_matpower</code>. However, this will return network data in PowerModels&#39; format, which is not the same as that of PowerModelsDistribution and PowerModelsDistributionStateEstimation.  Furthermore, Matpower files are single-conductor networks, which are typically not a good network representation for unbalanced distribution systems, where all phases should be explicitly modelled. To make the parsed matpower file multiconductor and adapted to the PowerModelsDistribution format, one can use the <code>make_multiconductor!</code> function from PowerModelsDistribution. Although this is a &quot;naive&quot; way to make the file suitable, it can be a good starting point.</p><h4 id="Multiconductor-vs-single-conductor-data-1"><a class="docs-heading-anchor" href="#Multiconductor-vs-single-conductor-data-1">Multiconductor vs single-conductor data</a><a class="docs-heading-anchor-permalink" href="#Multiconductor-vs-single-conductor-data-1" title="Permalink"></a></h4><p>While PowerModelsDistributionStateEstimation is designed with three-phase systems in mind, and thus relies on the PowerModelsDistribution data format, the package also allows to perform state estimation on single-conductor-equivalents or networks where some conductors/components are single-phase and other are three-phase. For instance, to perform single-phase state estimation on a Matpower network, it is sufficient to parse it as follows:</p><pre><code class="language-julia">number_of_conductors = 1
pm_path = joinpath(dirname(pathof(PowerModels)), &quot;..&quot;)
case5 = PowerModels.parse_file(&quot;$(pm_path)/test/data/matpower/case5.m&quot;) 
PowerModelsDistribution.make_multiconductor!(case5, number_of_conductors)</code></pre><p>if <code>number_of_conductors</code> is set to 1, the model will still be a single-phase-equivalent network, but structurally compatible with PowerModelsDistribution. if <code>number_of_conductors</code> is set to 3, the data will be transformed to a naive three-phase model. See examples in <code>test/single_conductor_branches.jl</code>.</p><h3 id="Writing-and-parsing-JSON-files-1"><a class="docs-heading-anchor" href="#Writing-and-parsing-JSON-files-1">Writing and parsing JSON files</a><a class="docs-heading-anchor-permalink" href="#Writing-and-parsing-JSON-files-1" title="Permalink"></a></h3><p>You can export/import a PowerModels or PowerModelsDistribution network data dictionary to a JSON file using the following functions:</p><ul><li><p>For PowerModelsDistribution: </p><ul><li><code>print_file</code> to export, </li><li><code>parse_file</code> to read.</li></ul></li><li><p>For PowerModels:</p><ul><li><code>export_file</code></li><li><code>parse_file</code></li></ul></li></ul><p>Clearly, parsing correct network data from a json file with <code>parse_file</code> will work if the file itself was created from a correct data  dictionary structure (e.g., with the export functionalities above). Trying to parse an otherwise created json file will probably not work,  unless created appropriately.</p><h2 id="Measurement-Data-1"><a class="docs-heading-anchor" href="#Measurement-Data-1">Measurement Data</a><a class="docs-heading-anchor-permalink" href="#Measurement-Data-1" title="Permalink"></a></h2><p>Measurement data must be added to a <code>MATHEMATICAL</code> data dictionary, of which they are a &quot;sub-dictionary&quot;. The user can either create the measurement dictionary from scratch, or it can be imported from a csv file in the right format, with the <code>add_measurements!</code> function. The measurement data in the csv file can be both real measurements (i.e., with an error), or &quot;fake&quot;/&quot;ideal&quot; measurements with no error. The function provides a functionality to add an error to &quot;fake&quot;/&quot;ideal&quot; measurements sampling the error from a Normal distribution. See the following:</p><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistributionStateEstimation.add_measurements!-Tuple{Dict, String}" href="#PowerModelsDistributionStateEstimation.add_measurements!-Tuple{Dict, String}"><code>PowerModelsDistributionStateEstimation.add_measurements!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">add_measurements!(data::Dict, meas_file::String; actual_meas::Bool = false, seed::Int=0)</code></pre><p>Add measurement data from separate CSV file to the PowerModelsDistribution data dictionary. To fully understand how this function works, it is recommended to first read the documentation section that describes the CSV measurement file format.</p><p><strong>Arguments</strong></p><ul><li><code>data</code>: MATHEMATICAL data dictionary in a format usable with PowerModelsDistribution</li><li><code>meas_file</code>: path to and name of file with measurement data</li><li><code>actual_meas</code>: default is false. When applied to non-normal distributions,       the effect is overruled to that of <code>true</code>. For normal distributions, the following applies:<ul><li><code>false</code>: the &quot;par<em>1&quot; in meas</em>file are not actual measurements, but, e.g.,   error-free powerflow results. Then, a fake measurement is built, extracting   a value with an error from the given normal distribution.</li><li><code>true</code>: the &quot;par<em>1&quot; values in meas</em>file are actual measurement values,   and the &quot;par_2&quot; are the σs of the measurements&#39; distributions. These are   directly used as input of the state estimator without further processing.</li><li>if a &quot;parse&quot; column is present in the CSV file, the <code>true</code> or <code>false</code> is associated   to each individual row (i.e., measurement), and overrules whatever the actual<em>meas   input of add</em>measurements!() itself is.</li></ul></li><li><code>seed</code>: random seed value to make the results reproducible and explore different   Monte Carlo scenarios when sampling measurement with errors from a probability distribution.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Electa-Git/PowerModelsDistributionStateEstimation.jl/blob/14f53ef1867945033576bc36b1e346644120ad05/src/io/measurement_parser.jl#L56-L78">source</a></section></article><p>An example of csv file in the right format can be found in PowerModelsDistributionStateEstimation/test/data/enwl/measurements/meas<em>data</em>example.csv and refers to network 1, feeder 1 of the ENWL data. The format of the csv input file is explained in the following subsection.</p><p>Furthermore, functionality is included to write a measurement file, with the <code>write_measurements!</code> function. This is useful for quick testing or when the user has no actual measurement data, and allows to generate measurement files from the results of powerflow calculations on the same network. It should be noted that this function sets the measurement errors so that they follow a Normal distribution.</p><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistributionStateEstimation.write_measurements!-Tuple{Type, Dict, Dict, String}" href="#PowerModelsDistributionStateEstimation.write_measurements!-Tuple{Type, Dict, Dict, String}"><code>PowerModelsDistributionStateEstimation.write_measurements!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">write_measurements!(model::Type, data::Dict, pf_results::Dict, path::String; exclude::Vector{String}=String[])</code></pre><p>Function to write a csv file with measurements, to be used to run state estimation calculations. The file is built starting from power flow results from PowerModelsDistribution.jl (or any dictionary with the same format). The measurements consist of voltage and power/current injections in correspondence of all generators and loads. The exact measurement type depends on the chosen power flow formulation, e.g., with the AC Polar formulation, these are voltage magnitude and active and reactive power.</p><p><strong>Arguments</strong></p><ul><li><code>model</code>: power flow type of the generated measurements, e.g., ACPUPowerModel.            If it does not match the power flow model of the <code>pf_results</code>, it might not work.            <code>pf_results</code> can be post-processed, e.g., polar results can be converted in rectangular            and viceversa, to make the result dictionary compatible.</li><li><code>data</code>: MATHEMATICAL data dictionary in a format usable with PowerModelsDistribution</li><li><code>pf_results</code>: PowerModelsDistribution solution dictionary or similar format</li><li><code>path</code>: path where the csv file will be generated and stored</li><li><code>exclude</code>: select quantities from the <code>pf_results</code> dictionary to be excluded from the measurement              generation. For example, to ignore generator results with ACPUPowerModel,              set exclude = [&quot;pg&quot;, &quot;qg&quot;].</li><li><code>σ</code>: standard deviation of demand/generation measurement, for voltage measurements       this is rescaled in <code>get_sigma()</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Electa-Git/PowerModelsDistributionStateEstimation.jl/blob/14f53ef1867945033576bc36b1e346644120ad05/src/io/measurement_parser.jl#L187-L208">source</a></section></article><p>The measurement &quot;sub-dictionary&quot; is now incorporated in the network data dictionary, and can be showed in REPL typing data[&quot;meas&quot;].</p><p>If there are pseudo measurements, or the user wants to explicitly describe measurements as non-Gaussian probability distributions, the same rules apply: either the measurements are provided as a csv file, or they can be created with the <code>write_measurements_and_pseudo!</code> function.</p><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistributionStateEstimation.write_measurements_and_pseudo!-Tuple{Type, Dict, Dict, String}" href="#PowerModelsDistributionStateEstimation.write_measurements_and_pseudo!-Tuple{Type, Dict, Dict, String}"><code>PowerModelsDistributionStateEstimation.write_measurements_and_pseudo!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">write_measurements_and_pseudo!(model::Type, data::Dict, pf_results::Dict, path::String; exclude::Vector{String}=String[], distribution_info::String, σ::Float64=0.005)</code></pre><p>Helper function to write a csv file with a combination of measurements and pseudo-measurements. Works similarly to write<em>measurements!() with additional support for non-Normal distributions for the pseudo-measurements. In order to use this function, the load data for pseudo measurements data[&quot;load&quot;] need to point to an external file where information on the probability distribution is stored. An example of such a file is distr</em>example.csv in test/extra/measurements. The arguments of the function are the same as write<em>measurements!(), with the addition of `distribution</em>info`: the path to external csv file for pseudo-measurements distributions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Electa-Git/PowerModelsDistributionStateEstimation.jl/blob/14f53ef1867945033576bc36b1e346644120ad05/src/io/measurement_parser.jl#L235-L245">source</a></section></article><p>Please note that this function has only been fully tested with the <code>ExtendedBeta</code> distribution. Some functionalities, such as the per unit conversion of pdfs whose parameters are not in per unit might not work for other distributions. Providing distributions that are already in per unit might allow to use this function directly, but it is not guaranteed. Furthermore, some assumptions need to hold to be able to correctly use this function:</p><ul><li>The distributions provided refer to active power pseudo measurements. The same distributions are scaled using the power factor to represent the reactive power of the same load.</li><li>The format of the external file with distribution information matches the example one: test/data/extra/measurements/distr_example.csv.</li></ul><p>In general, it is advised that users that intend to recur to non-Gaussian distributions build their own measurement creator/parser.</p><p>As state in the function description, the <code>data[&quot;load&quot;]</code> dictionary entries of pseudo measurements need to point to the distribution file. A helper function is provided for this purpose as well:</p><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>PowerModelsDistributionStateEstimation.assign_load_pseudo_measurement_info!(data::Dict, pseudo_load_list::Array, cluster_list::Array, csv_path::String; time_step::Int64=1, day::Int64=1)</code>. Check Documenter&#39;s build log for details.</p></div></div><h3 id="The-csv-(pseudo)-measurement-data-format-1"><a class="docs-heading-anchor" href="#The-csv-(pseudo)-measurement-data-format-1">The csv (pseudo) measurement data format</a><a class="docs-heading-anchor-permalink" href="#The-csv-(pseudo)-measurement-data-format-1" title="Permalink"></a></h3><p>In the present section, the term &quot;component&quot; refers to buses, branches, loads, generators or any other element present in the network data model. These need to be addressed using the singular term/abbreviation as present in the MATHEMATICAL data model, e.g. gen for generator. In the network data model, each component is identified by a unique index number (NB: there can be both a &quot;load 1&quot; and a &quot;gen 1&quot;, but there can&#39;t be two &quot;load 1&quot;).   The required csv measurement file features the following columns:</p><ul><li>meas_id: unique identifier of the given measurement. Must be an integer.</li><li>cmp_type: indicates which component the measurement refers to: bus, load, gen, branch, etc.</li><li>cmp_id: integer that indicates the index of the above component.</li><li>meas_type: this is &quot;G&quot; if the measured quantity is between phase and neutral, &quot;P&quot; if between phases.</li><li>meas_var: indicates which variable is measured. The entry must correspond to the variable name as defined in PowerModelsDistribution or PowerModelsDistributionStateEstimation, e.g., pg for the injected power from a generator, vm for a bus voltage magnitude, etc.</li><li>phase: phase the measurement refers to, i.e., 1, 2 or 3. If it is a three-phase measurement, this can be indicated with a &quot;[1, 2, 3]&quot;.</li><li>dst: type of continuous univariate distribution associated to the measurement. In the classic WLAV/WLS estimators, this is a &quot;Normal&quot; distribution. In this package, we allow a number of additional distributions. For details, see the manual section on &quot;Maximum Likelihood Estimation&quot;</li><li>par_1: is the first of the two parameters that define the measurement error distribution. For the Normal distribution, this is the mean.</li><li>par_2: second parameter of the distribution. For the Normal distribution this is the standard deviation.</li><li>par_3: can be missing or string, if the distribution requires a third parameter.</li><li>par_4: can be missing or string, if the distribution requires a third parameter.</li><li>crit: can be missing, or it assigns an individual SE criterion to the measurement in a given row (see <a href="../se_criteria/#Mathematical-Model-of-the-State-Estimation-Criteria-1">Mathematical Model of the State Estimation Criteria</a>).</li><li>parse: can be true or false (or missing). It should be true if the measurement provided are real measurements (i.e., with errors). It should be false if the measurements are not real but, e.g., generated with power flow calculations (i.e., they have no errors). In this case, a value with error is sampled from the distribution associated to the measurements, and used in the state estimation process.</li></ul><p>Note that the error parsing only works for Normal distributions. It will not return an error for non-Normal distributions, but will default to the same behaviour as setting parse to false.</p><p>The last three columns are optional and don&#39;t necessarily need to be part of the CSV files. If a row/measurement is characterized by a distribution that requires 4 parameters, while the rest of them only require 2, the par<em>3 and par</em>4 columns of all other measurements need to have &quot;missing&quot; values, which will be ignored. Similarly, &quot;missing&quot; values in the other optional columns can be set, and they are ignored.</p><h3 id="The-csv-distribution-file-format-1"><a class="docs-heading-anchor" href="#The-csv-distribution-file-format-1">The csv distribution file format</a><a class="docs-heading-anchor-permalink" href="#The-csv-distribution-file-format-1" title="Permalink"></a></h3><p>This section explains the format of the csv file that contains information relative to probability distribution for pseudo measurements. An example is test/data/extra/measurements/distr_example.csv. The file has the following columns:</p><ul><li>day: day to which the distribution refers, integer</li><li>time_step: time step to which the distribution refers, integer</li><li>cluster: load profile group or cluster, integer</li><li>par<em>1,par</em>2,par<em>2,par</em>4: parameters of the distribution, if less than four are required, can be missing. Otherwise, they are floats</li><li>distr: distribution type, string</li><li>per_unit: boolean, indicates whether the distribution has been rescaled to the unit values used in the SE calculations (true) or not (false). It is advised to used rescaled distributions.</li><li>PF: power factor. This is used to apply the same distribution, which is assumed to refer to the active power, to the reactive power</li></ul><h3 id="The-final-dictionary-format-1"><a class="docs-heading-anchor" href="#The-final-dictionary-format-1">The final dictionary format</a><a class="docs-heading-anchor-permalink" href="#The-final-dictionary-format-1" title="Permalink"></a></h3><p>In general, the measurement information needs to be correctly provided in the <code>data[&quot;meas&quot;]</code> sub-dictionary, as ultimately it is this which is used for the calculations. It is to the user to make sure that this is the case, regardless of which helper functions and files are used. Each measurement &quot;m&quot; needs to be unique, and should be similar to measurement &quot;1&quot; here:</p><pre><code class="language-julia">data[&quot;meas&quot;][&quot;1&quot;] =&gt; Dict{String,Any}(
    &quot;var&quot; =&gt; :pd,
    &quot;cmp&quot; =&gt; :load,
    &quot;cmp_id&quot; =&gt; 4
    &quot;dst&quot; =&gt; Any[ExtendedBeta{Float64}(α=1.18, β=7.1, min=-3.28684e-8, max=1.44621e-5), 0.0, 0.0],
    &quot;crit&quot; =&gt; &quot;rwlav&quot;
)</code></pre><p><code>var</code> is the variable to which the measurement refers. In this case, active power. <code>cmp</code> is the component type to which the measurement refers. In this case, a load. <code>cmp_id</code> is the unique id of this component. <code>dst</code> is a vector that contains the pdf of the measurement, for each phase separately and scaled to the correct units. At the moment, this is always a 3x1 vector, and phases to which loads are not used are assigned a 0.0. <strong>This is going to change very soon</strong> when upgrading to PowerModelsDistribution v0.10.0, in v0.2.0 of the present package. We will do our best to keep the docs up to date but there might be a delay. <code>crit</code> string that indicates the measurement&#39;s SE criterion, see <a href="../se_criteria/#Mathematical-Model-of-the-State-Estimation-Criteria-1">Mathematical Model of the State Estimation Criteria</a>.</p><h2 id="State-estimation-settings-1"><a class="docs-heading-anchor" href="#State-estimation-settings-1">State estimation settings</a><a class="docs-heading-anchor-permalink" href="#State-estimation-settings-1" title="Permalink"></a></h2><p>Finally, an indication on what type of state estimation needs to be performed should be provided using the &quot;se<em>settings&quot; dictionary. The `se</em>settings<code>dictionary contains up to three keys:</code>rescaler<code>,</code>criterion<code>and</code>number<em>of</em>gaussian<code>. The</code>rescaler<code>is a Float that multiplies the residual constraints. Depending on the specific case and solver, adding a rescaler can improve tractability, even quite significantly. If no entry is provided, this defaults to 1.0. The</code>criterion<code>is a String and allows the user to choose a **global** residual definition for all measurements. If different measurements need to have different criteria, this shouldn&#39;t be used, but rather a local individual needs to be assigned to each measurement. For details on which criteria are available and how to use them, see [Mathematical Model of the State Estimation Criteria](@ref). If no entry is provided, no action is taken, as individual criterion assignment is assumed. The</code>number<em>of</em>gaussian` is an Int and is only resorted to when the Gaussian Mixture criterion is chosen. In this context, it represents the number of Gaussian components of the model. If no entry is provided, this defaults to 10.</p><pre><code class="language-julia">&quot;se_settings&quot; =&gt; Dict{String,Any}(
    &quot;rescaler&quot; =&gt; 10,
    &quot;criterion&quot; =&gt; &quot;ga&quot;, #only for global criterion assignment
    &quot;number_of_gaussian&quot; =&gt; 6
)</code></pre><p>At this point, the data dictionary should have a structure similar to this:</p><pre><code class="language-julia">Dict{String,Any}(
    &quot;data_model&quot; =&gt; MATHEMATICAL,
    &quot;component_type&quot; =&gt; Dict{Any,Dict{String,Any}}(
        id =&gt; Dict{String,Any}(
            &quot;parameter&quot; =&gt; value,
            ...
        ),
        ...
    ),
    &quot;meas&quot; =&gt; Dict{Any,Dict{String,Any}}(
        id =&gt; Dict{String,Any}(
            &quot;parameter&quot; =&gt; value,
            ...
        ),
        ...
    ),
    &quot;se_settings&quot; =&gt; Dict{String,Any}(
        &quot;rescaler&quot; =&gt; value,
        &quot;criterion&quot; =&gt; &quot;chosen_criterion&quot; #only for global criterion assignment
    ),
    ...
)</code></pre><p>NB: do not confuse the &quot;se_settings&quot; dictionary key with the &quot;settings&quot; dictionary key, which is also present in the PowerModelsDistribution network data format.</p><h2 id="Putting-everything-together:-complete-input-data-1"><a class="docs-heading-anchor" href="#Putting-everything-together:-complete-input-data-1">Putting everything together: complete input data</a><a class="docs-heading-anchor-permalink" href="#Putting-everything-together:-complete-input-data-1" title="Permalink"></a></h2><p>The following script allows the user to visualize the various steps to build the data and display final structure:</p><pre><code class="language-julia">
data = parse_file(joinpath(BASE_DIR, &quot;test/data/extra/networks/case3_unbalanced.dss&quot;); data_model=MATHEMATICAL) #parses the network data
msr_path = joinpath(BASE_DIR, &quot;test/data/extra/measurements/case3_meas.csv&quot;) # indicates the path to measurement data csv file
add_measurements!(data, msr_path, actual_meas = false)                  # adds the measurement data to the network data dictionary
data[&quot;se_settings&quot;] = Dict{String,Any}(&quot;criterion&quot; =&gt; &quot;rwlav&quot;,
                                        &quot;rescaler&quot; =&gt; rescaler)# adds the state estimation settings to the data
display(data)                                                                # displays the first &quot;layer&quot; of the dictionary. The internal structure can be &quot;navigated&quot; like any other dictionary
</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../quickguide/">« Getting Started</a><a class="docs-footer-nextpage" href="../measurements/">Measurements and Conversions »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 26 May 2021 12:01">Wednesday 26 May 2021</span>. Using Julia version 1.6.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
