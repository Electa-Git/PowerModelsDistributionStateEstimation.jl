<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Bad Data Detection and Identification · PowerModelsDistributionStateEstimation.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">PowerModelsDistributionStateEstimation.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../quickguide/">Getting Started</a></li><li><a class="tocitem" href="../input_data_format/">Input Data Format</a></li><li><a class="tocitem" href="../measurements/">Measurements and Conversions</a></li><li><a class="tocitem" href="../se_criteria/">State Estimation Criteria</a></li><li class="is-active"><a class="tocitem" href>Bad Data Detection and Identification</a><ul class="internal"><li><a class="tocitem" href="#Chi-square-Analysis-1"><span>Chi-square Analysis</span></a></li><li><a class="tocitem" href="#Largest-Normalized-Residuals-1"><span>Largest Normalized Residuals</span></a></li><li><a class="tocitem" href="#LAV-Estimator-Residual-Analysis-1"><span>LAV Estimator Residual Analysis</span></a></li><li><a class="tocitem" href="#Other-Notes-1"><span>Other Notes</span></a></li></ul></li></ul></li><li><span class="tocitem">Library </span><ul><li><a class="tocitem" href="../formulations/">Power Flow Formulations</a></li><li><a class="tocitem" href="../problems/">Problem Specifications</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Bad Data Detection and Identification</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Bad Data Detection and Identification</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/Electa-Git/PowerModelsDistributionStateEstimation.jl/blob/master/docs/src/bad_data.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Bad-Data-Detection-and-Identification-1"><a class="docs-heading-anchor" href="#Bad-Data-Detection-and-Identification-1">Bad Data Detection and Identification</a><a class="docs-heading-anchor-permalink" href="#Bad-Data-Detection-and-Identification-1" title="Permalink"></a></h1><p>As of version 0.4.0, PMDSE has bad data detection and identification functionalities, namely:</p><ul><li>Chi-square test,</li><li>Largest normalized residuals,</li><li>Least absolute value (LAV) estimator residual analysis.</li></ul><p>The LAV is a robust estimator that presents bad data rejection properties. LAV residuals can be collected and sorted, and the measurements with higher  residuals are the ones of the bad data points. The LAV residual analysis can be done with all previous versions of the package too, but is made easier in v0.4.0: in versions up to 0.4.0 the user needs to pass <code>wlav</code> or <code>rwlav</code> as a state estimation criterion, and assign a unitary standard deviation for all weights or all measurements. Now it is sufficient to  pass <code>lav</code> as a state estimation criterion.</p><p>All these three techniques are very standard techniques, and a thorough theoretical discussion can be found in the well-known book: &quot;Power system state estimation - Theory and implementation&quot; by A. Abur and A. G. Exposito. Furthermore, numerous papers also address in which circumstances the different techniques are more or less effective.</p><p>Below, just a functional introduction.</p><p>First of all,</p><ul><li>Bad data <em>detection</em> consists of answering the yes/no question: &quot;is there bad data&quot;?</li><li>Bad data <em>identification</em> consists of locating which data points are bad (to subsequently correct them or delete them).</li></ul><p>All the presented techniques require the user to first run a state estimation algorithm, as they are based on the analysis of its residuals.</p><h2 id="Chi-square-Analysis-1"><a class="docs-heading-anchor" href="#Chi-square-Analysis-1">Chi-square Analysis</a><a class="docs-heading-anchor-permalink" href="#Chi-square-Analysis-1" title="Permalink"></a></h2><p>Chi-squares (<span>$\Chi^2$</span>) analysis is a bad data <em>detection</em> method. If bad data are detected, these still need to be identified.</p><p>The method is based on the following assumptions: if all measurement errors follow a Normal distribution, and there are no bad data, then the sum of the weighted squared residuals follows a Chi-square distributions with <em>m-n</em> degrees of freedom, where <em>m</em> is the number of measurements and <em>n</em> of the system variables.</p><p>The function <code>exceeds_chi_squares_threshold</code> takes as input the solution of a state estimation calculation and the data dictionary. It calculates the degrees of freedom and the sum of the weighted square residuals (where the weights are the inverse of each measurement&#39;s variance). If the state estimation that was run was a <code>wls</code> estimation with no weight rescaler, this sum corresponds to the objective value. However, the function always calculates the sum, to allow the user to use Chi-square calculations in combination with measurement rescalers or other state estimation criteria.</p><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistributionStateEstimation.exceeds_chi_squares_threshold-Tuple{Dict, Dict}" href="#PowerModelsDistributionStateEstimation.exceeds_chi_squares_threshold-Tuple{Dict, Dict}"><code>PowerModelsDistributionStateEstimation.exceeds_chi_squares_threshold</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">exceeds_chi_squares_threshold(sol_dict::Dict, data::Dict; prob_false::Float64=0.05, suppress_display::Bool=false)</code></pre><p>Standard bad data detection method that consists of performing a Chi squares analysis on the objective value, i.e., the sum of the residuals. The outcome of the analysis depends on the degrees of freedom of the problem, which are calculated calling the <code>get_degrees_of_freedom</code> function (see below).</p><p>This function returns:</p><ul><li>a Boolean. If <code>true</code>, there are probably bad data points, if <code>false</code> there probably are not.</li><li>the sum of the weighted squares of the residuals (which might be the optimization objective or not, depending on the settings) and the Χ² threshold value. </li></ul><p>Arguments:</p><ul><li><code>sol_dict</code>: solution dictionary, i.e., the default output dictionary of state estimation calculations,</li><li><code>data</code>: data input of the state estimation calculations, used to calculate the degrees of freedom,</li><li><code>prob_false</code>: probability of errors allowed in the Chi squares test, defaults to 0.05</li><li><code>suppress_display</code>: if <code>false</code>, the function also displays the result of the analysis, otherwise this is suppressed.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Electa-Git/PowerModelsDistributionStateEstimation.jl/blob/499c2b9cc516511f7f1bef40d35e6ebb4082b0d4/src/bad_data/chi_squares_test.jl#L1-L18">source</a></section></article><p>The function returns a boolean that states whether bad data are suspected, the value of the sum of the residuals and the threshold value above which bad data are suspected. The threshold value depends on the degrees of freedom and the detection confidence probability, that cab=n be set by the user. The default value of the latter is 0.05, as this is often the choice in the literature. </p><h2 id="Largest-Normalized-Residuals-1"><a class="docs-heading-anchor" href="#Largest-Normalized-Residuals-1">Largest Normalized Residuals</a><a class="docs-heading-anchor-permalink" href="#Largest-Normalized-Residuals-1" title="Permalink"></a></h2><p>Normalized residuals can be used for both bad data <em>detection</em> and <em>identification</em>. Let the residuals be <span>$r_i = h_i(\mathbf{x}) - \mathbf{z}$</span>, where <span>$h$</span> are the measurement functions, <span>$\mathbf{x}$</span> are the system variables and <span>$\mathbf{z}$</span> is the measurement vector. This is often the standard notation, e.g., in the book by Abur and Exposito. The normalized residuals <span>$r^N_i$</span> are:</p><div>\[\begin{align}
&amp;r_i^N = \frac{|r_i|}{\sqrt{\Omega_{ii}}} = \frac{|r_i|}{\sqrt{R_{ii}S_{ii}}}
\end{align}\]</div><p>The largest <span>$r^N$</span> is compared to a threshold, typically 3.0 in the literature. If its value exceeds the threshold, bad data are suspected, and the bad data point is identified as the measurement that corresponds to the largest <span>$r^N$</span> itself. This package contains different functions that allow to build the measurement matrix (H), the measurement error covariance matrix (R), the gain matrix (G), the hat matrix (K), the sensitivity matrix (S) and the residual covariance matrix (<span>$\Omega$</span>):</p><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>PowerModelsDistributionStateEstimation.build_H_matrix(functions::Vector, state::Array)::Matrix{Float64}</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>build_G_matrix(H::Matrix, R::Matrix)::Matrix{Float64}</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>build_R_matrix(data::Dict)::Matrix{Float64}</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>build_omega_matrix(R::Matrix{Float64}, H::Matrix{Float64}, G::Matrix{Float64})</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>build_omega_matrix(S::Matrix{Float64}, R::Matrix{Float64})</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>build_S_matrix(K::Matrix{Float64})</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>build_K_matrix(H::Matrix{Float64}, G::Matrix{Float64}, R::Matrix{Float64})</code>. Check Documenter&#39;s build log for details.</p></div></div><div>\[\Omega\]</div><p>can then be used in the function <code>normalized_residuals</code>, which calculates all <span>$r_i$</span>, returns the highest <span>$r^N$</span> and indicates whether its value exceeds the threshold or not. Again, the <span>$r_i$</span> calculation is independent of the chosen state estimation criterion or weight rescaler.</p><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistributionStateEstimation.normalized_residuals-Tuple{Dict, Dict, Matrix}" href="#PowerModelsDistributionStateEstimation.normalized_residuals-Tuple{Dict, Dict, Matrix}"><code>PowerModelsDistributionStateEstimation.normalized_residuals</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Adds the normalized residuals to the solution dictionary and returns the largest normalized residual, its index (i.e., the measurement it refers to), and whether it exceeds the given threshold <code>t</code> or not.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Electa-Git/PowerModelsDistributionStateEstimation.jl/blob/499c2b9cc516511f7f1bef40d35e6ebb4082b0d4/src/bad_data/largest_normalized_residuals.jl#L10-L13">source</a></section></article><p>Finally, a simplified version of the largest normalized residuals is available: <code>simple_normalized_residuals</code>, that instead of calculating the <span>$\Omega$</span> matrix, calculates the normalized residuals as:</p><div>\[\begin{align}
&amp;r_i^N = \frac{|r_i|}{\sqrt{\Omega_{ii}}} = \frac{|r_i|}{\sqrt{R_{ii}^2}}
\end{align}\]</div><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistributionStateEstimation.simple_normalized_residuals-Tuple{Dict, Dict, Matrix}" href="#PowerModelsDistributionStateEstimation.simple_normalized_residuals-Tuple{Dict, Dict, Matrix}"><code>PowerModelsDistributionStateEstimation.simple_normalized_residuals</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">simple_normalized_residuals(data::Dict, se_sol::Dict, R::Matrix)</code></pre><p>It normalizes the residuals only based on their standard deviation, no sensitivity matrix involved. R^2 replaces Ω, where Ω = S ⋅ R Avoids all the matrix calculations but is a &quot;simplified&quot; method</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Electa-Git/PowerModelsDistributionStateEstimation.jl/blob/499c2b9cc516511f7f1bef40d35e6ebb4082b0d4/src/bad_data/largest_normalized_residuals.jl#L1-L6">source</a></section></article><h2 id="LAV-Estimator-Residual-Analysis-1"><a class="docs-heading-anchor" href="#LAV-Estimator-Residual-Analysis-1">LAV Estimator Residual Analysis</a><a class="docs-heading-anchor-permalink" href="#LAV-Estimator-Residual-Analysis-1" title="Permalink"></a></h2><p>The LAV estimator is known to be inherently robust to bad data, as it is basically a linear regression. Thus, it is sufficient to run it and then check its residuals as in the piece of code below. The residuals do not even need to be calculated, because in a <code>LAV</code> estimation, they are by default reported as <code>res</code> in the solution dictionary. As such, the user only needs to sort the residuals in descending orders, see what their magnitude is, and whether some residuals are much higher than the others. The latter, in general, points out the bad data.</p><pre><code class="language-julia">    bad_data[&quot;se_settings&quot;] = Dict{String,Any}(&quot;criterion&quot; =&gt; &quot;lav&quot;,
                                            &quot;rescaler&quot; =&gt; 1)

    se_result_bd_lav = _PMDSE.solve_acp_red_mc_se(bad_data, solver)
    residual_tuples = [(m, maximum(meas[&quot;res&quot;])[1]) for (m, meas) in se_result_bd_lav[&quot;solution&quot;][&quot;meas&quot;]]
    sorted_tuples = sort(residual_tuples, by = last, rev = true)
    measurement_index_of_largest_residual = first(sorted_tuples[1])
    magnitude_of_largest_residual = last(sorted_tuples[1])
    ratio12 = (last(sorted_tuples[1])/last(sorted_tuples[2])) # ratio between the first and the second largest residuals.</code></pre><h2 id="Other-Notes-1"><a class="docs-heading-anchor" href="#Other-Notes-1">Other Notes</a><a class="docs-heading-anchor-permalink" href="#Other-Notes-1" title="Permalink"></a></h2><p>Virtually all bad data detection and identification methods from the literature are done &quot;a-posteriori&quot;, i.e., after running a state estimation, by performing statistical considerations on the measurement residuals, or &quot;a priori&quot; doing some measurement data pre-processing (these are not discussed but could be, e.g., removing missing data or absurd measurements like negative or zero voltage). Thus, it is easy for the user to use this framework to just run the state estimation calculations and then add customized bad data handling methods that take as input the input measurement dictionary and/or the output solution dictionary.</p><p>An example on how to use this package to perform bad data detection and identification can be found at this <a href="https://github.com/MartaVanin/SE_framework_paper_results">link</a>: see both its readme and the file <code>src/scripts/case_study_E.jl</code>.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../se_criteria/">« State Estimation Criteria</a><a class="docs-footer-nextpage" href="../formulations/">Power Flow Formulations »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 22 February 2022 15:32">Tuesday 22 February 2022</span>. Using Julia version 1.7.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
