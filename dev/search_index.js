var documenterSearchIndex = {"docs":
[{"location":"formulations/#Network-Formulations-1","page":"Power Flow Formulations","title":"Network Formulations","text":"","category":"section"},{"location":"formulations/#","page":"Power Flow Formulations","title":"Power Flow Formulations","text":"This section gives an overview of the three-phase power flow formulations that are available to perform state estimation in PowerModelsDistributionStateEstimation. All formulations except the Reduced ones are imported from PowerModels or PowerModelsDistribution. These are only a subset of the formulations available in these two packages. For further information please refer to their official documentation.","category":"page"},{"location":"formulations/#Type-Hierarchy-1","page":"Power Flow Formulations","title":"Type Hierarchy","text":"","category":"section"},{"location":"formulations/#","page":"Power Flow Formulations","title":"Power Flow Formulations","text":"Formulations (or \"PowerModels\") follow the type hierarchy of PowerModels and PowerModelsDistribution, reported here for convenience for the relevant cases. At the top of the type hierarchy are abstract types. Three exact nonlinear (non-convex) models are available at the top level:","category":"page"},{"location":"formulations/#","page":"Power Flow Formulations","title":"Power Flow Formulations","text":"abstract type PowerModels.AbstractACPModel <: PowerModels.AbstractPowerModel end\nabstract type PowerModels.AbstractACRModel <: PowerModels.AbstractPowerModel end\nabstract type PowerModels.AbstractIVRModel <: PowerModels.AbstractACRModel end","category":"page"},{"location":"formulations/#","page":"Power Flow Formulations","title":"Power Flow Formulations","text":"Abstract Models types are then used as the type parameter for PowerModels:","category":"page"},{"location":"formulations/#","page":"Power Flow Formulations","title":"Power Flow Formulations","text":"mutable struct PowerModels.ACPPowerModel <: PowerModels.AbstractACPModel PowerModels.@pm_fields end\nmutable struct PowerModels.ACRPowerModel <: PowerModels.AbstractACRModel PowerModels.@pm_fields end\nmutable struct PowerModels.IVRPowerModel <: PowerModels.AbstractIVRModel PowerModels.@pm_fields end","category":"page"},{"location":"formulations/#","page":"Power Flow Formulations","title":"Power Flow Formulations","text":"A \"reduced\" version of each of the three formulations above is derived in PowerModelsDistributionStateEstimation:","category":"page"},{"location":"formulations/#","page":"Power Flow Formulations","title":"Power Flow Formulations","text":"mutable struct PowerModelsDistributionStateEstimation.ReducedACPPowerModel <: PowerModels.AbstractACPModel PowerModels.@pm_fields end\nmutable struct PowerModelsDistributionStateEstimation.ReducedACRPowerModel <: PowerModels.AbstractACRModel PowerModels.@pm_fields end\nmutable struct PowerModelsDistributionStateEstimation.ReducedIVRPowerModel <: PowerModels.AbstractIVRModel PowerModels.@pm_fields end\n\nAbstractReducedModel = Union{ReducedACRPowerModel, ReducedACPPowerModel}","category":"page"},{"location":"formulations/#","page":"Power Flow Formulations","title":"Power Flow Formulations","text":"The reduced models are still exact for networks like those made available in the ENWL database, where there are no cable ground admittance, storage elements and active switches. A positive semi-definite (SDP) relaxation is also made available for state estimation in PowerModelsDistributionStateEstimation. The SDP model belongs to the following categories: conic models and branch flow (BF) models, and there relevant type structure is the following:","category":"page"},{"location":"formulations/#","page":"Power Flow Formulations","title":"Power Flow Formulations","text":"abstract type PowerModels.AbstractBFModel <: PowerModels.AbstractPowerModel end\nabstract type PowerModels.AbstractBFConicModel <: PowerModels.AbstractBFModel end\nabstract type PowerModelsDistribution.AbstractConicUBFModel <: PowerModels.AbstractBFConicModel end\nabstract type PowerModelsDistribution.SDPUBFModel <: PowerModelsDistribution.AbstractConicUBFModel end\n\nmutable struct PowerModelsDistribution.SDPUBFPowerModel <: PowerModelsDistribution.SDPUBFModel PowerModels.@pm_fields end","category":"page"},{"location":"formulations/#","page":"Power Flow Formulations","title":"Power Flow Formulations","text":"where UBF stands for unbalanced branch flow. Finally, a linear unbalanced branch flow model is available for state estimation: the LPUBFDiagModel, better known as LinDist3FlowModel.","category":"page"},{"location":"formulations/#","page":"Power Flow Formulations","title":"Power Flow Formulations","text":"abstract type PowerModelsDistribution.AbstractLPUBFModel <: PowerModelsDistribution.AbstractNLPUBFModel end\nabstract type PowerModelsDistribution.LPUBFDiagModel <: PowerModelsDistribution.AbstractLPUBFModel end\nconst PowerModelsDistribution.LinDist3FlowModel = PowerModelsDistribution.LPUBFDiagModel\n\nmutable struct PowerModelsDistribution.LPUBFDiagPowerModel <: PowerModelsDistribution.LPUBFDiagModel PowerModels.@pm_fields end\nconst PowerModelsDistribution.LinDist3FlowPowerModel = PowerModelsDistribution.LPUBFDiagPowerModel","category":"page"},{"location":"formulations/#Details-on-the-Formulations-1","page":"Power Flow Formulations","title":"Details on the Formulations","text":"","category":"section"},{"location":"formulations/#","page":"Power Flow Formulations","title":"Power Flow Formulations","text":"This sub-section reports for convenience the relevant literature for the formulations used in PowerModelsDistributionStateEstimation and is again a reduced version of the official PowerModelsDistribution documentation, available here.","category":"page"},{"location":"formulations/#AbstractACPModel-1","page":"Power Flow Formulations","title":"AbstractACPModel","text":"","category":"section"},{"location":"formulations/#","page":"Power Flow Formulations","title":"Power Flow Formulations","text":"Formulation without shunts: Mahdad, B., Bouktir, T., & Srairi, K. (2006). A three-phase power flow modelization: a tool for optimal location and control of FACTS devices in unbalanced power systems. In IEEE Industrial Electronics IECON (pp. 2238–2243).","category":"page"},{"location":"formulations/#","page":"Power Flow Formulations","title":"Power Flow Formulations","text":"See also:","category":"page"},{"location":"formulations/#","page":"Power Flow Formulations","title":"Power Flow Formulations","text":"Carpentier, J. (1962) Contribution to the economic dispatch problem. In Bulletin de la Societe Francoise des Electriciens, vol. 3 no. 8, pp. 431-447.\nCain, M. B., O' Neill, R. P. & Castillo, A. (2012). History of optimal power flow and Models. Available online","category":"page"},{"location":"formulations/#AbstractACRModel-1","page":"Power Flow Formulations","title":"AbstractACRModel","text":"","category":"section"},{"location":"formulations/#","page":"Power Flow Formulations","title":"Power Flow Formulations","text":"See:","category":"page"},{"location":"formulations/#","page":"Power Flow Formulations","title":"Power Flow Formulations","text":"Cain, M. B., O' Neill, R. P. & Castillo, A. (2012). History of optimal power flow and Models. Available online","category":"page"},{"location":"formulations/#AbstractIVRModel-1","page":"Power Flow Formulations","title":"AbstractIVRModel","text":"","category":"section"},{"location":"formulations/#","page":"Power Flow Formulations","title":"Power Flow Formulations","text":"O' Neill, R. P., Castillo, A. & Cain, M. B. (2012). The IV formulation and linear approximations of the ac optimal power flow problem. Available online","category":"page"},{"location":"formulations/#SDPUBFModel-1","page":"Power Flow Formulations","title":"SDPUBFModel","text":"","category":"section"},{"location":"formulations/#","page":"Power Flow Formulations","title":"Power Flow Formulations","text":"Gan, L., & Low, S. H. (2014). Convex relaxations and linear approximation for optimal power flow in multiphase radial networks. In PSSC (pp. 1–9). Wroclaw, Poland. doi:10.1109/PSCC.2014.7038399","category":"page"},{"location":"formulations/#LPUBFDiagModel-or-LinDist3FlowModel-1","page":"Power Flow Formulations","title":"LPUBFDiagModel or LinDist3FlowModel","text":"","category":"section"},{"location":"formulations/#","page":"Power Flow Formulations","title":"Power Flow Formulations","text":"Sankur, M. D., Dobbe, R., Stewart, E., Callaway, D. S., & Arnold, D. B. (2016). A linearized power flow model for optimization in unbalanced distribution systems. arXiv:1606.04492v2","category":"page"},{"location":"quickguide/#Quick-Start-Guide-1","page":"Getting Started","title":"Quick Start Guide","text":"","category":"section"},{"location":"quickguide/#","page":"Getting Started","title":"Getting Started","text":"To perform a state estimation (SE), a network data file (e.g. \"case3_unbalanced.dss\" in ../test/data/extra/networks) needs to be acquired, together with its related measurement file (e.g. \"case3_meas.csv\" in ../test/data/extra/measurements). The absolute path to the package is provided through the constant BASE_DIR. Network and measurement data will be merged and a SE can be run as follows:","category":"page"},{"location":"quickguide/#","page":"Getting Started","title":"Getting Started","text":"using PowerModels, PowerModelsDistribution, PowerModelsDistributionStateEstimation\nusing JuMP, Ipopt\n\n#full paths to files\nntw_path = joinpath(BASE_DIR, \"test/data/extra/networks/case3_unbalanced.dss\")\nmsr_path = joinpath(BASE_DIR, \"test/data/extra/measurements/case3_meas.csv\")\n\n#parse network data file\ndata = PowerModelsDistribution.parse_file(ntw_path; data_model=MATHEMATICAL)\n\n#add measurement data to network data file\nadd_measurements!(data, msr_path, actual_meas = true)\n\n#set state estimation settings\ndata[\"se_settings\"] = Dict{String,Any}(\"criterion\" => \"rwlav\", \"rescaler\" => 1)\n\n#set solver parameters\nslv = JuMP.optimizer_with_attributes(Ipopt.Optimizer, \"tol\"=>1e-6, \"print_level\"=>0)\n\n#run state estimation\nse_result = run_acp_mc_se(data, slv)","category":"page"},{"location":"quickguide/#","page":"Getting Started","title":"Getting Started","text":"The run commands return detailed results in the form of a dictionary, following PowerModels format, and can be saved for future processing, like in se_result above.","category":"page"},{"location":"quickguide/#Accessing-Different-Formulations-1","page":"Getting Started","title":"Accessing Different Formulations","text":"","category":"section"},{"location":"quickguide/#","page":"Getting Started","title":"Getting Started","text":"Different run functions correspond to different formulations. The function run_acp_mc_se uses the AC Polar form, run_acr_mc_se uses the AC rectangular, etc. Alternatively, the formulation type can directly be passed to the generic run_mc_se function:","category":"page"},{"location":"quickguide/#","page":"Getting Started","title":"Getting Started","text":"run_mc_se(data, ACPPowerModel, slv)","category":"page"},{"location":"quickguide/#","page":"Getting Started","title":"Getting Started","text":"It should be noted that not all solvers can handle all problem types. For example, to use the SDP formulation, you have to use a SDP-capable solver, such as the open-source solver SCS.","category":"page"},{"location":"quickguide/#Providing-a-Warm-Start-1","page":"Getting Started","title":"Providing a Warm Start","text":"","category":"section"},{"location":"quickguide/#","page":"Getting Started","title":"Getting Started","text":"Providing a (good) initial value to some or all optimization variables can reduce the number of solver iterations. PowerModelsDistributionStateEstimation provides the assign_start_to_variables! function.","category":"page"},{"location":"quickguide/#","page":"Getting Started","title":"Getting Started","text":"PowerModelsDistributionStateEstimation.assign_start_to_variables!(data)","category":"page"},{"location":"quickguide/#","page":"Getting Started","title":"Getting Started","text":"PowerModelsDistributionStateEstimation.assign_start_to_variables!(data, start_values_source)","category":"page"},{"location":"quickguide/#","page":"Getting Started","title":"Getting Started","text":"Alternatively, the user can directly assign a value or vector (depending on the dimensions of the variable) in the data dictionary, under the key variablename_start. The example below shows how to do it for the vm and va variables.","category":"page"},{"location":"quickguide/#","page":"Getting Started","title":"Getting Started","text":"data = parse_file(\"case3_unbalanced.dss\"; data_model=MATHEMATICAL)\ndata[\"bus\"][\"2\"][\"vm_start\"] = [0.996, 0.996, 0.996]\ndata[\"bus\"][\"2\"][\"va_start\"] = [0.00, -2.0944, 2.0944]","category":"page"},{"location":"quickguide/#","page":"Getting Started","title":"Getting Started","text":"It should be noted that providing a bad initial value might result in longer calculation times or convergence issues, so the start value assignment should be done cautiously. If no initial value is provided, a flat start is assigned by default. The default initial value of each variable is indicated in the function where the variable is defined, as the last argument of the comp_start_value function (this is valid for both imported PowerModelsDistribution and native PowerModelsDistributionStateEstimation variables).","category":"page"},{"location":"quickguide/#Updating-Variable-Bounds-1","page":"Getting Started","title":"Updating Variable Bounds","text":"","category":"section"},{"location":"quickguide/#","page":"Getting Started","title":"Getting Started","text":"In constrained optimization, reducing the search space might be an effective way to reduce solver time. Search space reduction can be done by assigning bounds to the variables. This must also be done attentively, though, to make sure that the feasible space is not cut, i.e., that feasible solutions are not removed by this process. This can be avoided if good knowledge of the system is available or if some variable have particularly obvious bounds, e.g., voltage magnitude cannot be negative, so its lower bound can be set to 0 without risk. Similar to providing a warm start, it is to user discretion to assign meaningful and \"safe\" variable bounds. PowerModelsDistributionStateEstimation has functions that allow to define bounds on voltage magnitude, power generation (active and reactive) or power demand (active and reactive):","category":"page"},{"location":"quickguide/#","page":"Getting Started","title":"Getting Started","text":"PowerModelsDistributionStateEstimation.update_voltage_bounds!(data::Dict; v_min=0.0, v_max=Inf)","category":"page"},{"location":"quickguide/#PowerModelsDistributionStateEstimation.update_voltage_bounds!-Tuple{Dict}","page":"Getting Started","title":"PowerModelsDistributionStateEstimation.update_voltage_bounds!","text":"update_voltage_bounds!(data; v_min, v_max)\n\nFunction that allows to automatically set upper (vmax) and lower (vmin) voltage bounds for all buses.\n\n\n\n\n\n","category":"method"},{"location":"quickguide/#","page":"Getting Started","title":"Getting Started","text":"PowerModelsDistributionStateEstimation.update_generator_bounds!(data; p_min, p_max, q_min, q_max)","category":"page"},{"location":"quickguide/#","page":"Getting Started","title":"Getting Started","text":"PowerModelsDistributionStateEstimation.update_load_bounds!(data; p_min, p_max, q_min, q_max)","category":"page"},{"location":"quickguide/#","page":"Getting Started","title":"Getting Started","text":"or, alternatively, all the above at once:","category":"page"},{"location":"quickguide/#","page":"Getting Started","title":"Getting Started","text":"PowerModelsDistributionStateEstimation.update_all_bounds!(data; v_min, v_max, pg_min, pg_max, qg_min, qg_max, pd_min, pd_max, qd_min, qd_max)","category":"page"},{"location":"quickguide/#","page":"Getting Started","title":"Getting Started","text":"Alternatively, the user can directly assign a value or vector (depending on the dimensions of the variable) in the data dictionary, under the key variablenamemin/variablenamemax. The example below shows how to do it for the active power.","category":"page"},{"location":"quickguide/#","page":"Getting Started","title":"Getting Started","text":"data[\"load\"][\"1\"][\"pmax\"] = [1.0, 1.0, 1.0]\ndata[\"load\"][\"1\"][\"pmin\"] = [0.0, 0.0, 0.0]","category":"page"},{"location":"quickguide/#Updating-Residual-Bounds-1","page":"Getting Started","title":"Updating Residual Bounds","text":"","category":"section"},{"location":"quickguide/#","page":"Getting Started","title":"Getting Started","text":"Residuals are a type of variable that is specific to the state estimation problem (and not, e.g., of power flow studies). If you do not know what a residual is, please read the Problem Specifications section of the documentation. While the residuals as defined in the present package are always non-negative (default lower bound is 0), there is no default upper bound. A function is available to add customized upper bounds:","category":"page"},{"location":"quickguide/#","page":"Getting Started","title":"Getting Started","text":"PowerModelsDistributionStateEstimation.assign_residual_ub!(data; chosen_upper_bound=100.0, rescale=false)","category":"page"},{"location":"problems/#Problem-Specifications-1","page":"Problem Specifications","title":"Problem Specifications","text":"","category":"section"},{"location":"problems/#","page":"Problem Specifications","title":"Problem Specifications","text":"The main purpose of PowerModelsDistributionStateEstimation is to solve state estimation problems. For a number of purposes, it might be useful to perform power flow or OPF calculations, within the context of a state estimation study. For example, power flow calculations can be used to validate the accuracy of the state estimator, or to generate artificial measurement data, if these are not available. Power flow and OPF calculations can be accessed from PowerModelsDistribution. The description of these problems can be found in PowerModelsDistribution's documentation.","category":"page"},{"location":"problems/#State-estimation-problem-implementation-1","page":"Problem Specifications","title":"State estimation problem implementation","text":"","category":"section"},{"location":"problems/#","page":"Problem Specifications","title":"Problem Specifications","text":"For a bus injection model, the structure of the state estimation problem is the following. See the implementation at src/prob/se.jl for all the models'  implementations and their details. The functions preceded by a \"_PMD.\" are imported from PowerModelsDistributions.jl. Those without prefix are original PowerModelsDistributionStateEstimation functions, those preceded by a \"PowerModelsDistributionStateEstimation.\" are present in both and therefore needed disambiguation.","category":"page"},{"location":"problems/#Variables-1","page":"Problem Specifications","title":"Variables","text":"","category":"section"},{"location":"problems/#","page":"Problem Specifications","title":"Problem Specifications","text":"\nPowerModelsDistributionStateEstimation.variable_mc_bus_voltage(pm; bounded = true)\n_PMD.variable_mc_branch_power(pm; bounded = true)\n_PMD.variable_mc_transformer_power(pm; bounded = true)\n_PMD.variable_mc_gen_power_setpoint(pm; bounded = true)\nvariable_mc_load(pm; report = true)\nvariable_mc_residual(pm, bounded = true)\nvariable_mc_measurement(pm, bounded = false)","category":"page"},{"location":"problems/#","page":"Problem Specifications","title":"Problem Specifications","text":"It can be seen that the first variables are bounded. It is up to the user to define reasonable upper/lower bounds that don't cut the feasible space of the problem. They can in principle be set as +/- infinity if no better information on the bounds is available.","category":"page"},{"location":"problems/#Constraints-1","page":"Problem Specifications","title":"Constraints","text":"","category":"section"},{"location":"problems/#","page":"Problem Specifications","title":"Problem Specifications","text":"\nfor (i,gen) in _PMD.ref(pm, :gen)\n    _PMD.constraint_mc_gen_setpoint(pm, i)\nend\nfor (i,bus) in _PMD.ref(pm, :ref_buses)\n    @assert bus[\"bus_type\"] == 3\n    _PMD.constraint_mc_theta_ref(pm, i)\nend\nfor (i,bus) in _PMD.ref(pm, :bus)\n    PowerModelsDistributionStateEstimation.constraint_mc_load_power_balance_se(pm, i)\nend\nfor (i,branch) in _PMD.ref(pm, :branch)\n    _PMD.constraint_mc_ohms_yt_from(pm, i)\n    _PMD.constraint_mc_ohms_yt_to(pm,i)\nend\nfor (i,meas) in _PMD.ref(pm, :meas)\n    constraint_mc_residual(pm, i)\nend\n\nfor i in _PMD.ids(pm, :transformer)\n    _PMD.constraint_mc_transformer_power(pm, i)\nend","category":"page"},{"location":"problems/#Objective-1","page":"Problem Specifications","title":"Objective","text":"","category":"section"},{"location":"problems/#","page":"Problem Specifications","title":"Problem Specifications","text":"    objective_mc_se(pm)","category":"page"},{"location":"problems/#","page":"Problem Specifications","title":"Problem Specifications","text":"For branch flow/linearized/SDP models, the variable space changes and also some of the constraints, while the objective always stays the same.","category":"page"},{"location":"problems/#Mathematical-formulation-1","page":"Problem Specifications","title":"Mathematical formulation","text":"","category":"section"},{"location":"problems/#","page":"Problem Specifications","title":"Problem Specifications","text":"For a detailed description of the mathematical model, please refer to the following publication. In the mathematical description below, the following sets are used,","category":"page"},{"location":"problems/#","page":"Problem Specifications","title":"Problem Specifications","text":"beginalign\n\nmboxsets  nonumber \n mathcalN mbox - busesnonumber \n mathcalR mbox - references busesnonumber \n mathcalE mathcalE_i  mbox - branches branches to and from bus i nonumber \n mathcalG mathcalG_i mbox - generators and generators at bus i nonumber \n mathcalL mathcalL_i mbox - loads and loads at bus i nonumber \n mathcalS mathcalS_i mbox - shunts and shunts at bus i nonumber \n Phi Phi_ij mbox - conductors conductors of branch (ij) nonumber \n\nendalign","category":"page"},{"location":"problems/#","page":"Problem Specifications","title":"Problem Specifications","text":"Bold characters indicate vectors and matrices\nThe textdiag(cdot) operator takes the diagonal (vector) from a matrix\nThe (cdot)^H indicates the conjugate transpose of a matrix","category":"page"},{"location":"problems/#","page":"Problem Specifications","title":"Problem Specifications","text":"The julia problem above, can be associated to the following mathematical description","category":"page"},{"location":"problems/#","page":"Problem Specifications","title":"Problem Specifications","text":"Variables:","category":"page"},{"location":"problems/#","page":"Problem Specifications","title":"Problem Specifications","text":"\nbeginalign\n  mathbfS^g_k mathbfS^d_k mathbfU_i    forall k in mathcalG k in mathcalL i in mathcalN nonumber       mathbfS_ij boldsymbolrho_m  forall (ij) in mathcalE m in mathcalM nonumber\nendalign","category":"page"},{"location":"problems/#","page":"Problem Specifications","title":"Problem Specifications","text":"Constraints:","category":"page"},{"location":"problems/#","page":"Problem Specifications","title":"Problem Specifications","text":"beginalign\nmathbfangle U_r = 0 -120 120 deg   forall r in mathcalR \nsum_substackk in mathcalG_i mathbfS^g_k - sum_substackk in mathcalL_i mathbfS^d_k - sum_substackk in mathcalS_i  mathbfU_i mathbfU^H_i (mathbfY^s_k)^H  =\nsum_substack(ij)in mathcalE_i diag(mathbfS_ij)  forall iin mathcalN\n  mathbfS_ij =  mathbfU_i mathbfU_i^H left( mathbfY^sh_ijright)^H + mathbfU_i left(mathbfU_i- mathbfU_j right)^H (mathbfY_ij)^H   forall (ij)in mathcalE \n mathbfS_ij =  mathbfU_i mathbfU_i^H left( mathbfY_ij + mathbfY^sh_ijright)^H - mathbfU_i mathbfU^H_j mathbfY^H_ij   forall (ij)in mathcalE \n mathbfS_ji = mathbfU_j mathbfU_j^H left( mathbfY_ij + mathbfY^sh_ji right)^H - mathbfU^H_i mathbfU_j mathbfY^H_ij  forall (ij)in mathcalE \n boldsymbolrho_m = r_m(mathbff_m(mathbfx) mathbfz_m boldsymbolsigma_m)\n mathbff_m(mathbfx) - mathbfz_m _pboldsymbolsigma^p_m  forall m in mathcalM mathbfx in mathcalX\nendalign","category":"page"},{"location":"problems/#","page":"Problem Specifications","title":"Problem Specifications","text":"Objective: math \\begin{equation}   \\text{minimize} \\; \\; \\sum_{\\substack{m \\in \\mathcal{M}}} \\boldsymbol{\\rho}_{m}. \\end{equation} The residual rho_m phi is a function that allows to represent the uncertainty on a given measurement m, performed on conductor phi. In the mathematical description above, it is identified as the function r, which is depending on the measurement mathbfz, and another function: f.","category":"page"},{"location":"problems/#","page":"Problem Specifications","title":"Problem Specifications","text":"The function f_mphi are used to handle measurements z_mphi that are performed on quantities that do not refer to the problems' variable space. There are the measurements conversions described in the Measurements And Conversions section of the documentation.","category":"page"},{"location":"problems/#","page":"Problem Specifications","title":"Problem Specifications","text":"Function r_mphi, on the other hand, depends on what state estimation criterion is chosen, e.g., WLS, WLAV, MLE. The form that r_mphi takes in the various cases is defined in the section State Estimation Criteria of the documentation.","category":"page"},{"location":"input_data_format/#Input-Data-Format-1","page":"Input Data Format","title":"Input Data Format","text":"","category":"section"},{"location":"input_data_format/#","page":"Input Data Format","title":"Input Data Format","text":"The data input required by PowerModelsDistributionStateEstimation takes the form of a dictionary and can be subdivided in three parts:","category":"page"},{"location":"input_data_format/#","page":"Input Data Format","title":"Input Data Format","text":"Network data\nMeasurement data\nState estimation settings","category":"page"},{"location":"input_data_format/#","page":"Input Data Format","title":"Input Data Format","text":"The network data contains all the information relative to the physics of the analyzed network: topology, line impedance, power demand and generation, etc.. The measurement data contains all the information relative to the available (pseudo-)measurements available for that network: number and placement of meters, measured quantities (power, voltage...) and measurement accuracy. The state estimation settings allow the user to choose the type of estimation criterion to be used (e.g., WLS, WLAV,..) and add a weight rescaler. More details on each of the three parts can be found in the following sections of this manual.","category":"page"},{"location":"input_data_format/#Network-Data-Input-1","page":"Input Data Format","title":"Network Data Input","text":"","category":"section"},{"location":"input_data_format/#","page":"Input Data Format","title":"Input Data Format","text":"The network data input of PowerModelsDistributionStateEstimation is based on that of PowerModelsDistribution (PMD). In the versions supported by PowerModelsDistributionStateEstimation, PMD allows for two input data formats:","category":"page"},{"location":"input_data_format/#","page":"Input Data Format","title":"Input Data Format","text":"The ENGINEERING model (extensively documented here)\nThe MATHEMATICAL model","category":"page"},{"location":"input_data_format/#","page":"Input Data Format","title":"Input Data Format","text":"The idea behind offering two options is that the ENGINEERING model is quite intuitive and allows a non-developer to easily generate data and use the PMD package as made available. The MATHEMATICAL model allows developers to explore the details of the PMD package and/or add extra information that can be passed as additional input to go beyond the functionalities that are natively offered in PMD. Ultimately, both PMD and PowerModelsDistributionStateEstimation use the MATHEMATICAL model to build the input for the calculations, but PMD can be provided directly an ENGINEERING model, which is then transformed at runtime. This is not the case in PowerModelsDistributionStateEstimation, which requires measurement data and state estimation settings to perform state estimation calculations. These two take the form of \"sub-dictionaries\" that need to be appended to a PMD MATHEMATICAL network data model dictionary. If added to the ENGINEERING data model, they will be ignored in the transformation to the MATHEMATICAL model, returning an error. For additional information on the network data input, the user is referred to the PMD manual. The user can build the network data from scratch, for example writing a native julia parser that builds the dictionary starting from external files, or reading an otherwise created JSON file with the right dictionary structure. However, to encourage the use and creation of easily reproducible test cases, two network data parsers are made available, for the following files:","category":"page"},{"location":"input_data_format/#","page":"Input Data Format","title":"Input Data Format","text":"OpenDSS files, for which we use the parsers from PowerModelsDistribution,\nA native ENWL files parser, courtesy of Sander Claeys (@sanderclaeys).","category":"page"},{"location":"input_data_format/#Parsing-OpenDSS-files-1","page":"Input Data Format","title":"Parsing OpenDSS files","text":"","category":"section"},{"location":"input_data_format/#","page":"Input Data Format","title":"Input Data Format","text":"To parse an OpenDSS file into PowerModelsDistribution's default ENGINEERING format, use the parse_file function:","category":"page"},{"location":"input_data_format/#","page":"Input Data Format","title":"Input Data Format","text":"eng = PowerModelsDistribution.parse_file(\"path/to/file/file_name.dss\")","category":"page"},{"location":"input_data_format/#","page":"Input Data Format","title":"Input Data Format","text":"To obtain the MATHEMATICAL model it is possible to transform the data model using the transform_data_model function.","category":"page"},{"location":"input_data_format/#","page":"Input Data Format","title":"Input Data Format","text":"math = PowerModelsDistribution.transform_data_model(eng)","category":"page"},{"location":"input_data_format/#","page":"Input Data Format","title":"Input Data Format","text":"A small example of OpenDSS network data can be found in PowerModelsDistributionStateEstimation/test/data/extra/networks","category":"page"},{"location":"input_data_format/#Parsing-ENWL-files-1","page":"Input Data Format","title":"Parsing ENWL files","text":"","category":"section"},{"location":"input_data_format/#","page":"Input Data Format","title":"Input Data Format","text":"ENWL files are a collection of 25 real low voltage distribution networks (each of the networks' feeders is also individually accessible) and realistic demand/generation profile data, made available by the Electricity North West and The University of Manchester.","category":"page"},{"location":"input_data_format/#","page":"Input Data Format","title":"Input Data Format","text":"The data is available in OpenDSS-like format in PowerModelsDistributionStateEstimation/test/data/enwl/networks and can be parsed with the PowerModelsDistribution parse_file function. A specific feeder fdr of a network ntw should be parsed to the ENGINEERING model, using:","category":"page"},{"location":"input_data_format/#","page":"Input Data Format","title":"Input Data Format","text":"eng_data = PowerModelsDistribution.parse_file(PowerModelsDistributionStateEstimation.get_enwl_dss_path(ntw,fdr),data_model=PowerModelsDistribution.ENGINEERING)","category":"page"},{"location":"input_data_format/#","page":"Input Data Format","title":"Input Data Format","text":"All feeders are featured with a detailed transformer model. It might be convenient or necessary to drop the transformer model and define the source bus as a slack bus: this (slightly) improves tractability and in low voltage power flow and state estimation studies, the exact substation model is often not taken into account. The removal should happen at the ENGINEERING data stage:","category":"page"},{"location":"input_data_format/#","page":"Input Data Format","title":"Input Data Format","text":"PowerModelsDistributionStateEstimation.rm_enwl_transformer!(eng_data)","category":"page"},{"location":"input_data_format/#PowerModelsDistributionStateEstimation.rm_enwl_transformer!-Tuple{Any}","page":"Input Data Format","title":"PowerModelsDistributionStateEstimation.rm_enwl_transformer!","text":"rm_enwl_transformer!(data_eng)\n\nThis function removes the transformer from a parsed ENWL ENGINEERING data file.\n\n\n\n\n\n","category":"method"},{"location":"input_data_format/#","page":"Input Data Format","title":"Input Data Format","text":"The ENWL feeders feature a high number of buses that are only used to interpolate the topology layout (i.e., where the cables are) but that host no device. Function reduce_enwl_lines_eng! is included specifically to simplify the data and remove the nodes and lines in excess in order to (considerably) improve tractability. It is highly recommended to use it. The resulting feeder is equivalent to the original one in terms of physical properties, and the calculation results are the same. The function can be applied both to an ENGINEERING and a MATHEMATICAL data model.","category":"page"},{"location":"input_data_format/#","page":"Input Data Format","title":"Input Data Format","text":"PowerModelsDistributionStateEstimation.reduce_enwl_lines_eng!(eng_data)","category":"page"},{"location":"input_data_format/#PowerModelsDistributionStateEstimation.reduce_enwl_lines_eng!-Tuple{Any}","page":"Input Data Format","title":"PowerModelsDistributionStateEstimation.reduce_enwl_lines_eng!","text":"reduce_enwl_lines_eng!(data_eng)\n\nThis function removes all trailing lines from a parsed ENWL ENGINEERING data file.\n\n\n\n\n\n","category":"method"},{"location":"input_data_format/#","page":"Input Data Format","title":"Input Data Format","text":"PowerModelsDistributionStateEstimation.reduce_enwl_lines_math!(math_data)","category":"page"},{"location":"input_data_format/#PowerModelsDistributionStateEstimation.reduce_enwl_lines_math!-Tuple{Any}","page":"Input Data Format","title":"PowerModelsDistributionStateEstimation.reduce_enwl_lines_math!","text":"reduce_enwl_lines_math!(data_math)\n\nThis function removes all trailing lines from a parsed ENWL MATHEMATICAL data file.\n\n\n\n\n\n","category":"method"},{"location":"input_data_format/#","page":"Input Data Format","title":"Input Data Format","text":"Contrary to \"regular\" OpenDSS files, load profile information needs to be parsed and added to the ENWL feeder ENGINEERING data obtained so far. This is accomplished using the insert_profiles! function:","category":"page"},{"location":"input_data_format/#","page":"Input Data Format","title":"Input Data Format","text":"PowerModelsDistributionStateEstimation.insert_profiles!(data, season, devices, pfs; t=missing, useactual=true)","category":"page"},{"location":"input_data_format/#PowerModelsDistributionStateEstimation.insert_profiles!-NTuple{4,Any}","page":"Input Data Format","title":"PowerModelsDistributionStateEstimation.insert_profiles!","text":"insert_profiles!(data, season, devices, pfs; t=missing, useactual=true)\n\nThis function adds the load profiles to the parsed ENWL ENGINEERING data data.\n\nArguments\n\ndata: ENGINEERING data model of the feeder\nseason: \"summer\", \"winter\"\ndevices: \"load\", \"pv\", \"ev\", \"ehp\", \"uchp\"\npfs: power factor of the devices\nt: time-step\n\nExample\n\njulia> data = parse_file(get_enwl_dss_path(10, 1))\njulia> insert_profiles!(data, \"summer\", [\"load\", \"pv\"], [0.95, 0.90], t = 144)\n\n\n\n\n\n","category":"method"},{"location":"input_data_format/#","page":"Input Data Format","title":"Input Data Format","text":"The ENWL data set features a number of low-carbon technologies profiles: electric vehicles (EV), electric heat pumps (EHP), micro-CHP (uCHP), photovoltaic panels (PV). \"load\" indicates the \"traditional\" residential load.","category":"page"},{"location":"input_data_format/#Measurement-Data-1","page":"Input Data Format","title":"Measurement Data","text":"","category":"section"},{"location":"input_data_format/#","page":"Input Data Format","title":"Input Data Format","text":"Measurement data must be added to a MATHEMATICAL data dictionary, of which they are a \"sub-dictionary\". The user can either create the measurement dictionary from scratch, or it can be imported from a csv file in the right format, with the add_measurements! function. The measurement data in the csv file can be both real measurements (i.e., with an error), or \"fake\"/\"ideal\" measurements with no error. The function provides a functionality to add an error to \"fake\"/\"ideal\" measurements sampling the error from a Normal distribution. See the following:","category":"page"},{"location":"input_data_format/#","page":"Input Data Format","title":"Input Data Format","text":"PowerModelsDistributionStateEstimation.add_measurements!(data::Dict, meas_file::String; actual_meas::Bool = false, seed::Int=0)","category":"page"},{"location":"input_data_format/#PowerModelsDistributionStateEstimation.add_measurements!-Tuple{Dict,String}","page":"Input Data Format","title":"PowerModelsDistributionStateEstimation.add_measurements!","text":"add_measurements!(data::Dict, meas_file::String; actual_meas::Bool = false, seed::Int=0)\n\nAdd measurement data from separate CSV file to the PowerModelsDistribution data dictionary. To fully understand how this function works, it is recommended to first read the documentation section that describes the CSV measurement file format.\n\nArguments\n\ndata: MATHEMATICAL data dictionary in a format usable with PowerModelsDistribution\nmeas_file: path to and name of file with measurement data\nactual_meas: default is false. When applied to non-normal distributions,       the effect is overruled to that of true. For normal distributions, the following applies:\nfalse: the \"par1\" in measfile are not actual measurements, but, e.g.,   error-free powerflow results. Then, a fake measurement is built, extracting   a value with an error from the given normal distribution.\ntrue: the \"par1\" values in measfile are actual measurement values,   and the \"par_2\" are the σs of the measurements' distributions. These are   directly used as input of the state estimator without further processing.\nif a \"parse\" column is present in the CSV file, the true or false is associated   to each individual row (i.e., measurement), and overrules whatever the actualmeas   input of addmeasurements!() itself is.\nseed: random seed value to make the results reproducible and explore different   Monte Carlo scenarios when sampling measurement with errors from a probability distribution.\n\n\n\n\n\n","category":"method"},{"location":"input_data_format/#","page":"Input Data Format","title":"Input Data Format","text":"An example of csv file in the right format can be found in PowerModelsDistributionStateEstimation/test/data/enwl/measurements/measdataexample.csv and refers to network 1, feeder 1 of the ENWL data. The format of the csv input file is explained in the following subsection.","category":"page"},{"location":"input_data_format/#","page":"Input Data Format","title":"Input Data Format","text":"Furthermore, functionality is included to write a measurement file, with the write_measurements! function. This is useful for quick testing or when the user has no actual measurement data, and allows to generate measurement files from the results of powerflow calculations on the same network. It should be noted that this function sets the measurement errors so that they follow a Normal distribution.","category":"page"},{"location":"input_data_format/#","page":"Input Data Format","title":"Input Data Format","text":"PowerModelsDistributionStateEstimation.write_measurements!(model::Type, data::Dict, pf_results::Dict, path::String)","category":"page"},{"location":"input_data_format/#PowerModelsDistributionStateEstimation.write_measurements!-Tuple{Type,Dict,Dict,String}","page":"Input Data Format","title":"PowerModelsDistributionStateEstimation.write_measurements!","text":"write_measurements!(model::Type, data::Dict, pf_results::Dict, path::String; exclude::Vector{String}=String[])\n\nFunction to write a csv file with measurements, to be used to run state estimation calculations. The file is built starting from power flow results from PowerModelsDistribution.jl (or any dictionary with the same format). The mesurements consist of the voltage and power/current injection in correspondence of all generators and loads. The exact measurement type depends on the chosen power flow formulation, e.g., with the AC Polar formulation, these are voltage magnitude and active and reactive power.\n\nArguments\n\nmodel: power flow type of the generated measurements, e.g., ACPPowerModel.            If it does not match the power flow model of the pf_results, it might not work.            pf_results can be post-processed, e.g., polar results can be converted in rectangular            and viceversa, to make the result dictionary compatible.\ndata: MATHEMATICAL data dictionary in a format usable with PowerModelsDistribution\npf_results: PowerModelsDistribution solution dictionary or similar format\npath: path where the csv file will be generated and stored\nexclude: select quantities from the pf_results dictionary to be excluded from the measurement              generation. For example, to ignore generator results with ACPPowerModel,              set exclude = [\"pg\", \"qg\"].\nσ: standard deviation of demand/generation measurement, for voltage measurements       this is rescaled in get_sigma()\n\n\n\n\n\n","category":"method"},{"location":"input_data_format/#","page":"Input Data Format","title":"Input Data Format","text":"The measurement \"sub-dictionary\" is now incorporated in the network data dictionary, and can be showed in REPL typing data[\"meas\"].","category":"page"},{"location":"input_data_format/#","page":"Input Data Format","title":"Input Data Format","text":"If there are pseudo measurements, or the user wants to explicitly describe measurements as non-Gaussian probability distributions, the same rules apply: either the measurements are provided as a csv file, or they can be created with the write_measurements_and_pseudo! function.","category":"page"},{"location":"input_data_format/#","page":"Input Data Format","title":"Input Data Format","text":"PowerModelsDistributionStateEstimation.write_measurements_and_pseudo!(model::Type, data::Dict, pf_results::Dict, path::String; exclude::Vector{String}=String[], distribution_info::String, σ::Float64=0.005)","category":"page"},{"location":"input_data_format/#PowerModelsDistributionStateEstimation.write_measurements_and_pseudo!-Tuple{Type,Dict,Dict,String}","page":"Input Data Format","title":"PowerModelsDistributionStateEstimation.write_measurements_and_pseudo!","text":"write_measurements_and_pseudo!(model::Type, data::Dict, pf_results::Dict, path::String; exclude::Vector{String}=String[], distribution_info::String, σ::Float64=0.005)\n\nHelper function to write a csv file with a combination of measurements and pseudo-measurements. Works similarly to writemeasurements!() with additional support for non-Normal distributions for the pseudo-measurements. In order to use this function, the load data for pseudo measurements data[\"load\"] need to point to an external file where information on the probability distribution is stored. An example of such a file is distrexample.csv in test/extra/measurements. The arguments of the function are the same as writemeasurements!(), with the addition of `distributioninfo`: the path to external csv file for pseudo-measurements distributions.\n\n\n\n\n\n","category":"method"},{"location":"input_data_format/#","page":"Input Data Format","title":"Input Data Format","text":"Please note that this function has only been fully tested with the ExtendedBeta distribution. Some functionalities, such as the per unit conversion of pdfs whose parameters are not in per unit might not work for other distributions. Providing distributions that are already in per unit might allow to use this function directly, but it is not guaranteed. Furthermore, some assumptions need to hold to be able to correctly use this function:","category":"page"},{"location":"input_data_format/#","page":"Input Data Format","title":"Input Data Format","text":"The distributions provided refer to active power pseudo measurements. The same distributions are scaled using the power factor to represent the reactive power of the same load.\nThe format of the external file with distribution information matches the example one: test/data/extra/measurements/distr_example.csv.","category":"page"},{"location":"input_data_format/#","page":"Input Data Format","title":"Input Data Format","text":"In general, it is advised that users that intend to recur to non-Gaussian distributions build their own measurement creator/parser.","category":"page"},{"location":"input_data_format/#","page":"Input Data Format","title":"Input Data Format","text":"As state in the function description, the data[\"load\"] dictionary entries of pseudo measurements need to point to the distribution file. A helper function is provided for this purpose as well:","category":"page"},{"location":"input_data_format/#","page":"Input Data Format","title":"Input Data Format","text":"PowerModelsDistributionStateEstimation.assign_load_pseudo_measurement_info!(data::Dict, pseudo_load_list::Array, cluster_list::Array, csv_path::String; time_step::Int64=1, day::Int64=1)","category":"page"},{"location":"input_data_format/#The-csv-(pseudo)-measurement-data-format-1","page":"Input Data Format","title":"The csv (pseudo) measurement data format","text":"","category":"section"},{"location":"input_data_format/#","page":"Input Data Format","title":"Input Data Format","text":"In the present section, the term \"component\" refers to buses, branches, loads, generators or any other element present in the network data model. These need to be addressed using the singular term/abbreviation as present in the MATHEMATICAL data model, e.g. gen for generator. In the network data model, each component is identified by a unique index number (NB: there can be both a \"load 1\" and a \"gen 1\", but there can't be two \"load 1\").   The required csv measurement file features the following columns:","category":"page"},{"location":"input_data_format/#","page":"Input Data Format","title":"Input Data Format","text":"meas_id: unique identifier of the given measurement. Must be an integer.\ncmp_type: indicates which component the measurement refers to: bus, load, gen, branch, etc.\ncmp_id: integer that indicates the index of the above component.\nmeas_type: this is \"G\" if the measured quantity is between phase and neutral, \"P\" if between phases.\nmeas_var: indicates which variable is measured. The entry must correspond to the variable name as defined in PowerModelsDistribution or PowerModelsDistributionStateEstimation, e.g., pg for the injected power from a generator, vm for a bus voltage magnitude, etc.\nphase: phase the measurement refers to, i.e., 1, 2 or 3. If it is a three-phase measurement, this can be indicated with a \"[1, 2, 3]\".\ndst: type of continuous univariate distribution associated to the measurement. In the classic WLAV/WLS estimators, this is a \"Normal\" distribution. In this package, we allow a number of additional distributions. For details, see the manual section on \"Maximum Likelihood Estimation\"\npar_1: is the first of the two parameters that define the measurement error distribution. For the Normal distribution, this is the mean.\npar_2: second parameter of the distribution. For the Normal distribution this is the standard deviation.\npar_3: can be missing or string, if the distribution requires a third parameter.\npar_4: can be missing or string, if the distribution requires a third parameter.\ncrit: can be missing, or it assigns an individual SE criterion to the measurement in a given row. This can be used in combination with the \"mixed\" criterion (see Mathematical Model of the State Estimation Criteria).\nparse: can be true or false (or missing). It should be true if the measurement provided are real measurements (i.e., with errors). It should be false if the measurements are not real but, e.g., generated with power flow calculations (i.e., they have no errors). In this case, a value with error is sampled from the distribution associated to the measurements, and used in the state estimation process.","category":"page"},{"location":"input_data_format/#","page":"Input Data Format","title":"Input Data Format","text":"Note that the error parsing only works for Normal distributions. It will not return an error for non-Normal distributions, but will default to the same behaviour as setting parse to false.","category":"page"},{"location":"input_data_format/#","page":"Input Data Format","title":"Input Data Format","text":"The last three columns are optional and don't necessarily need to be part of the CSV files. If a row/measurement is characterized by a distribution that requires 4 parameters, while the rest of them only require 2, the par3 and par4 columns of all other measurements need to have \"missing\" values, which will be ignored. Similarly, \"missing\" values in the other optional columns can be set, and they are ignored.","category":"page"},{"location":"input_data_format/#The-csv-distribution-file-format-1","page":"Input Data Format","title":"The csv distribution file format","text":"","category":"section"},{"location":"input_data_format/#","page":"Input Data Format","title":"Input Data Format","text":"This section explains the format of the csv file that contains information relative to probability distribution for pseudo measurements. An example is test/data/extra/measurements/distr_example.csv. The file has the following columns:","category":"page"},{"location":"input_data_format/#","page":"Input Data Format","title":"Input Data Format","text":"day: day to which the distribution refers, integer\ntime_step: time step to which the distribution refers, integer\ncluster: load profile group or cluster, integer\npar1,par2,par2,par4: parameters of the distribution, if less than four are required, can be missing. Otherwise, they are floats\ndistr: distribution type, string\nper_unit: boolean, indicates whether the distribution has been rescaled to the unit values used in the SE calculations (true) or not (false). It is advised to used rescaled distributions.\nPF: power factor. This is used to apply the same distribution, which is assumed to refer to the active power, to the reactive power","category":"page"},{"location":"input_data_format/#The-final-dictionary-format-1","page":"Input Data Format","title":"The final dictionary format","text":"","category":"section"},{"location":"input_data_format/#","page":"Input Data Format","title":"Input Data Format","text":"In general, the measurement information needs to be correctly provided in the data[\"meas\"] sub-dictionary, as ultimately it is this which is used for the calculations. It is to the user to make sure that this is the case, regardless of which helper functions and files are used. Each measurement \"m\" needs to be unique, and should be similar to measurement \"1\" here:","category":"page"},{"location":"input_data_format/#","page":"Input Data Format","title":"Input Data Format","text":"data[\"meas\"][\"1\"] => Dict{String,Any}(\n    \"var\" => :pd,\n    \"cmp\" => :load,\n    \"cmp_id\" => 4\n    \"dst\" => Any[ExtendedBeta{Float64}(α=1.18, β=7.1, min=-3.28684e-8, max=1.44621e-5), 0.0, 0.0],\n    \"crit\" => \"rwlav\"\n)","category":"page"},{"location":"input_data_format/#","page":"Input Data Format","title":"Input Data Format","text":"var is the variable to which the measurement refers. In this case, active power. cmp is the component type to which the measurement refers. In this case, a load. cmp_id is the unique id of this component. dst is a vector that contains the pdf of the measurement, for each phase separately and scaled to the correct units. At the moment, this is always a 3x1 vector, and phases to which loads are not used are assigned a 0.0. This is going to change very soon when upgrading to PowerModelsDistribution v0.10.0, in v0.2.0 of the present package. We will do our best to keep the docs up to date but there might be a delay. crit optional entry which is only used in case the mixed SE criteria is chosen for the state estimation. See Mathematical Model of the State Estimation Criteria.","category":"page"},{"location":"input_data_format/#State-estimation-settings-1","page":"Input Data Format","title":"State estimation settings","text":"","category":"section"},{"location":"input_data_format/#","page":"Input Data Format","title":"Input Data Format","text":"Finally, an indication on what type of state estimation needs to be performed should be provided using the \"sesettings\" dictionary. The \"sesettings\" dictionary contains two keys: \"rescaler\" and \"criterion\". The \"rescaler\" consists of one value or an array of two values used to multiply the residual constraints (and in some cases also to put an offset on them) in the state estimation problem. Depending on the case the rescaler can improve tractability, even quite significantly. For more details on the use of the rescaler, the user can refer to the \"State Estimation Criteria\" section of this manual. The \"criterion\" allows the user to choose the \"type\" of state estimation to be performed, the classic examples being weighted least squares (WLS) and weighted least absolute values (WLAV). For details on which criteria are available and how to use them, the user is again referred to the \"State Estimation Criteria\" section of this manual.","category":"page"},{"location":"input_data_format/#","page":"Input Data Format","title":"Input Data Format","text":"If the user does not provide any \"se_settings\", this dictionary automatically created when running state estimation calculations, and set to the default rescaler value of 1 and estimation criterion of \"rwlav\":","category":"page"},{"location":"input_data_format/#","page":"Input Data Format","title":"Input Data Format","text":"\"se_settings\" => Dict{String,Any}(\n    \"rescaler\" => 1,\n    \"criterion\" => \"rwlav\"\n)","category":"page"},{"location":"input_data_format/#","page":"Input Data Format","title":"Input Data Format","text":"At this point, the data dictionary should have a structure similar to this:","category":"page"},{"location":"input_data_format/#","page":"Input Data Format","title":"Input Data Format","text":"Dict{String,Any}(\n    \"data_model\" => MATHEMATICAL,\n    \"component_type\" => Dict{Any,Dict{String,Any}}(\n        id => Dict{String,Any}(\n            \"parameter\" => value,\n            ...\n        ),\n        ...\n    ),\n    \"meas\" => Dict{Any,Dict{String,Any}}(\n        id => Dict{String,Any}(\n            \"parameter\" => value,\n            ...\n        ),\n        ...\n    ),\n    \"se_settings\" => Dict{String,Any}(\n        \"rescaler\" => value,\n        \"criterion\" => \"chosen_criterion\"  \n    ),\n    ...\n)","category":"page"},{"location":"input_data_format/#","page":"Input Data Format","title":"Input Data Format","text":"NB: do not confuse the \"se_settings\" dictionary key with the \"settings\" dictionary key, which is also present in the PowerModelsDistribution network data format.","category":"page"},{"location":"input_data_format/#Putting-everything-together:-complete-input-data-1","page":"Input Data Format","title":"Putting everything together: complete input data","text":"","category":"section"},{"location":"input_data_format/#","page":"Input Data Format","title":"Input Data Format","text":"The following script allows the user to visualize the various steps to build the data and display final structure:","category":"page"},{"location":"input_data_format/#","page":"Input Data Format","title":"Input Data Format","text":"\ndata = parse_file(joinpath(BASE_DIR, \"test/data/extra/networks/case3_unbalanced.dss\"); data_model=MATHEMATICAL) #parses the network data\nmsr_path = joinpath(BASE_DIR, \"test/data/extra/measurements/case3_meas.csv\") # indicates the path to measurement data csv file\nadd_measurements!(data, msr_path, actual_meas = false)                  # adds the measurement data to the network data dictionary\ndata[\"se_settings\"] = Dict{String,Any}(\"criterion\" => \"rwlav\",\n                                        \"rescaler\" => rescaler)# adds the state estimation settings to the data\ndisplay(data)                                                                # displays the first \"layer\" of the dictionary. The internal structure can be \"navigated\" like any other dictionary\n","category":"page"},{"location":"#PowerModelsDistributionStateEstimation.jl-Documentation-1","page":"Home","title":"PowerModelsDistributionStateEstimation.jl Documentation","text":"","category":"section"},{"location":"#Overview-1","page":"Home","title":"Overview","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"PowerModelsDistributionStateEstimation.jl is an extension package of PowerModelsDistribution.jl for three-phase static Power System State Estimation.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"A Power System State Estimator determines the most-likely state of power system given a set of uncertainties, e.g., measurement errors, pseudo-measurements, etc. These uncertainties may pertain to any quantity of any network component, e.g., voltage magnitude (vm) of a bus, power demand (pd) of a load, etc.","category":"page"},{"location":"#Installation-1","page":"Home","title":"Installation","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"The latest stable release of PowerModelsDistributionStateEstimation can be installed using the Julia package manager:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"] add PowerModelsDistributionStateEstimation","category":"page"},{"location":"#","page":"Home","title":"Home","text":"To be able to use PowerModelsDistributionStateEstimation, at least one solver is required. For our package tests, we rely on Ipopt and SCS solvers, since they do not have license restrictions. Both solvers can be installed using the package manager:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"] add Ipopt","category":"page"},{"location":"#","page":"Home","title":"Home","text":"] add SCS","category":"page"},{"location":"#","page":"Home","title":"Home","text":"However, it should be noted that, depending on the problem type, these solvers might not be the most appropriate/efficient choice.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"In order to test whether the package works, run:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"] test PowerModelsDistributionStateEstimation","category":"page"},{"location":"measurements/#Measurement-Conversion-1","page":"Measurements and Conversions","title":"Measurement Conversion","text":"","category":"section"},{"location":"measurements/#Introduction-1","page":"Measurements and Conversions","title":"Introduction","text":"","category":"section"},{"location":"measurements/#","page":"Measurements and Conversions","title":"Measurements and Conversions","text":"Any network formulation has a specific variable space, e.g., ACP includes vm, va, px and qx[1]. w = vm^2 is the lifted voltage variable native to branch flow conic and linear forms. The conversions for the reduced formulations work identically as their non-reduced equivalent.","category":"page"},{"location":"measurements/#","page":"Measurements and Conversions","title":"Measurements and Conversions","text":"[1]: The x in px, qx, cmx, cax, crx and cix   indicates that these variables exists for branches (~), generators (g) and   loads (-). In order to capture the variable for a specific element it   should be rewritten, e.g., \"px\" respectively becomes \"p\", \"pg\" and   \"pd\".","category":"page"},{"location":"measurements/#","page":"Measurements and Conversions","title":"Measurements and Conversions","text":"- vm va cmx cax crx cix px qx vr vi w\nACP N N SF X F F N N X X X\nACR S PP SF X MF MF N N N N X\nIVR S PP S PP N N M M N N X\nSDP X X X X X X N* N* X X N\nLD3F S X SF X X X N N X X N","category":"page"},{"location":"measurements/#","page":"Measurements and Conversions","title":"Measurements and Conversions","text":"where:","category":"page"},{"location":"measurements/#","page":"Measurements and Conversions","title":"Measurements and Conversions","text":"F:  conversion of type Fraction\nM:  conversion of type Multiplication\nMF: conversion of type MultiplicationFraction\nN:  native to the network formulation\nPP: conversion of type Tangent\nS: conversion of type Square\nSF: conversion of type SquareFraction\nX:  not provided","category":"page"},{"location":"measurements/#","page":"Measurements and Conversions","title":"Measurements and Conversions","text":"The N* in the SDP formulation indicates that those variable are only native for generators, loads and other devices/extensions, but not for measurements that refer to branch flows, yet.","category":"page"},{"location":"measurements/#Conversions-1","page":"Measurements and Conversions","title":"Conversions","text":"","category":"section"},{"location":"measurements/#","page":"Measurements and Conversions","title":"Measurements and Conversions","text":"Certain measurement variables may not be natively supported in the formulation space. Consequently, it becomes necessary to convert them into that specific space. This is accomplished through the inclusion of an additional constraint(s). The different types of conversion constraints are enumerated in what follows.","category":"page"},{"location":"measurements/#Tangent-1","page":"Measurements and Conversions","title":"Tangent","text":"","category":"section"},{"location":"measurements/#","page":"Measurements and Conversions","title":"Measurements and Conversions","text":"The conversion type Tangent  allows to include va measurements in the ACR and IVR formulation, and cax measurements in the IVR formulation, respectively through:","category":"page"},{"location":"measurements/#","page":"Measurements and Conversions","title":"Measurements and Conversions","text":"begineqnarray\n      tan(textva)   = fractextvitextvr              \n      tan(textcax)  = fractextcixtextcrx\nendeqnarray","category":"page"},{"location":"measurements/#","page":"Measurements and Conversions","title":"Measurements and Conversions","text":"These are non-linear equality constraints, modeled using @NLconstraint.","category":"page"},{"location":"measurements/#Fraction-1","page":"Measurements and Conversions","title":"Fraction","text":"","category":"section"},{"location":"measurements/#","page":"Measurements and Conversions","title":"Measurements and Conversions","text":"The conversion type Fraction allows to include crx and cix measurements in the ACP formulation, respectively through:","category":"page"},{"location":"measurements/#","page":"Measurements and Conversions","title":"Measurements and Conversions","text":"begineqnarray\n      textcrx = fractextpxcdotcos(textva)+textqxcdotsin(textva)textvm \n      textcix = fractextpxcdotsin(textva)-textqxcdotcos(textva)textvm\nendeqnarray","category":"page"},{"location":"measurements/#","page":"Measurements and Conversions","title":"Measurements and Conversions","text":"These are non-linear equality constraints, modeled using @NLconstraint.","category":"page"},{"location":"measurements/#Multiplication-1","page":"Measurements and Conversions","title":"Multiplication","text":"","category":"section"},{"location":"measurements/#","page":"Measurements and Conversions","title":"Measurements and Conversions","text":"The conversion type Multiplication allows to include px and qx measurements in the IVR formulation, respectively through:","category":"page"},{"location":"measurements/#","page":"Measurements and Conversions","title":"Measurements and Conversions","text":"begineqnarray\n      textpx = textvrcdottextcrx + textvicdottextcix \n      textqx = textvicdottextcrx - textvrcdottextcix\nendeqnarray","category":"page"},{"location":"measurements/#","page":"Measurements and Conversions","title":"Measurements and Conversions","text":"These are quadratic equality constraints, modeled using @constraint.","category":"page"},{"location":"measurements/#MultiplicationFraction-1","page":"Measurements and Conversions","title":"MultiplicationFraction","text":"","category":"section"},{"location":"measurements/#","page":"Measurements and Conversions","title":"Measurements and Conversions","text":"The conversion type MultiplicationFraction allows to include crx and cix measurements in the ACR formulation, respectively through:","category":"page"},{"location":"measurements/#","page":"Measurements and Conversions","title":"Measurements and Conversions","text":"begineqnarray\n      textcrx = fractextpxcdottextvr+textqxcdottextvitextvr^2+textvi^2 \n      textcix = fractextpxcdottextvi-textqxcdottextvrtextvr^2+textvi^2 \nendeqnarray","category":"page"},{"location":"measurements/#","page":"Measurements and Conversions","title":"Measurements and Conversions","text":"These are non-linear equality constraints, modeled using @NLconstraint.","category":"page"},{"location":"measurements/#SquareFraction-1","page":"Measurements and Conversions","title":"SquareFraction","text":"","category":"section"},{"location":"measurements/#","page":"Measurements and Conversions","title":"Measurements and Conversions","text":"The conversion type SquareFraction allows to include cmx measurements in the ACP and ACR formulation, through:","category":"page"},{"location":"measurements/#","page":"Measurements and Conversions","title":"Measurements and Conversions","text":"beginequation\n      textcmx^2 = fractextpx^2 + textqx^2textvm^2  \nendequation","category":"page"},{"location":"measurements/#","page":"Measurements and Conversions","title":"Measurements and Conversions","text":"If the conversion is applied to the LinDist3Flow formulation, then vm^2 is replaced by w. These are non-linear equality constraints, modeled using @NLconstraint.","category":"page"},{"location":"measurements/#Square-1","page":"Measurements and Conversions","title":"Square","text":"","category":"section"},{"location":"measurements/#","page":"Measurements and Conversions","title":"Measurements and Conversions","text":"The conversion type Square allows to include vm measurements in the ACR and IVR formulation, and cmx measurements in the IVR formulation, respectively through:","category":"page"},{"location":"measurements/#","page":"Measurements and Conversions","title":"Measurements and Conversions","text":"begineqnarray\n      textvm^2     = textvi^2 + textvr^2                  \n      textcmx^2    = textcix^2 + textcrx^2    \nendeqnarray","category":"page"},{"location":"measurements/#","page":"Measurements and Conversions","title":"Measurements and Conversions","text":"These are quadratic equality constraints, modeled using @constraint.","category":"page"},{"location":"measurements/#No-conversion-provided-1","page":"Measurements and Conversions","title":"No conversion provided","text":"","category":"section"},{"location":"measurements/#","page":"Measurements and Conversions","title":"Measurements and Conversions","text":"As displayed in the Table, some conversions are not provided. This is because the measured quantities are either unlikely to take place in practice, e.g., w, or tend to appear in pairs, e.g., cmx and cax with PMUs. In the latter case, it is more efficient to transform cax and cmx into rectangular variables a priori and then use them, for instance, with IVR.","category":"page"},{"location":"se_criteria/#Mathematical-Model-of-the-State-Estimation-Criteria-1","page":"State Estimation Criteria","title":"Mathematical Model of the State Estimation Criteria","text":"","category":"section"},{"location":"se_criteria/#","page":"State Estimation Criteria","title":"State Estimation Criteria","text":"Let X be the random variable associated to a measurement m ∈ 𝓜 and x ∈ 𝓧  the related variable, where:","category":"page"},{"location":"se_criteria/#","page":"State Estimation Criteria","title":"State Estimation Criteria","text":"𝓜 denotes the set of measurements,\n𝓧 denotes the (extended) variable space of the OPF problem.","category":"page"},{"location":"se_criteria/#","page":"State Estimation Criteria","title":"State Estimation Criteria","text":"Currently, the following univariate continuous distributions are supported through the Distributions.jl package:","category":"page"},{"location":"se_criteria/#","page":"State Estimation Criteria","title":"State Estimation Criteria","text":"Exponential\nWeibull\nNormal\nLog-Normal\nGamma\nBeta\nExtended Beta","category":"page"},{"location":"se_criteria/#","page":"State Estimation Criteria","title":"State Estimation Criteria","text":"ExtendedBeta","category":"page"},{"location":"se_criteria/#PowerModelsDistributionStateEstimation.ExtendedBeta","page":"State Estimation Criteria","title":"PowerModelsDistributionStateEstimation.ExtendedBeta","text":"ExtendedBeta\n\nThe extended beta distribution with shape parameters α and β, and optional support parameters min and max has a probability density function\n\nf(x α β textmin textmax) =\n    begincases\n        0                                                                                              textifx  textmin               \n        frac(x-textmin)^α-1 (textmax-x)^β-1B(αβ) (textmax-textmin)^α+β-1  textiftextmin  x  textmax \n        0                                                                                              textifx  max\n    endcases\n\nwhere B(α,β) is a Beta function.\n\n\n\n\n\n","category":"type"},{"location":"se_criteria/#","page":"State Estimation Criteria","title":"State Estimation Criteria","text":"The state of a power system can be determined based on a specific estimation  criterion. The state estimator criteria can be classified into two groups based  on the random variable X:","category":"page"},{"location":"se_criteria/#","page":"State Estimation Criteria","title":"State Estimation Criteria","text":"Gaussian\nwlav: weighted least absolute value (exact)\nrwlav: relaxed weighted least absolute value (exact relaxation)\nwls: weighted least square (exact)\nrwls: relaxed weighted least square (exact relaxation)\nNon-Gaussian\ngmm: Gaussian mixture model (approximation)\nmle: maximum likelihood estimation (exact)","category":"page"},{"location":"se_criteria/#","page":"State Estimation Criteria","title":"State Estimation Criteria","text":"The user has to specify the criterion through the se_settings (Input Data Format). If no criterion is specified, it will default to rwlav in the Gaussian case  and mle in the non-Gaussian case.","category":"page"},{"location":"se_criteria/#","page":"State Estimation Criteria","title":"State Estimation Criteria","text":"To use a mixed criterion, it is not sufficient to set the criterion in  se_settings as mixed. In addition to this, an individual dictionary entry  for every measurement in data[\"meas\"] needs to be added, to state which  criterion is associated to each measurement. The individual criterion entry needs to be placed under a crit key. For example: data[\"meas\"][\"1\"][\"crit\"] = \"rwlav\" and data[\"meas\"][\"2\"][\"crit\"] = \"mle\". A basic function to assign different criteria to different measurement is provided:","category":"page"},{"location":"se_criteria/#","page":"State Estimation Criteria","title":"State Estimation Criteria","text":"PowerModelsDistributionStateEstimation.assign_default_individual_criterion!(data; chosen_criterion=\"rwlav\")","category":"page"},{"location":"se_criteria/#","page":"State Estimation Criteria","title":"State Estimation Criteria","text":"Furthermore, a rescaler can be introduced to improve the convergence of the state estimation. The user has to specify the rescaler through the se_settings (Input Data Format). If no rescaler is specified, it will default to 1.0.","category":"page"},{"location":"se_criteria/#Gaussian-State-Estimation-Criteria-1","page":"State Estimation Criteria","title":"Gaussian State Estimation Criteria","text":"","category":"section"},{"location":"se_criteria/#WLAV-and-rWLAV-1","page":"State Estimation Criteria","title":"WLAV and rWLAV","text":"","category":"section"},{"location":"se_criteria/#","page":"State Estimation Criteria","title":"State Estimation Criteria","text":"The WLAV criterion represents the absolute value norm (p=1) and is given by","category":"page"},{"location":"se_criteria/#","page":"State Estimation Criteria","title":"State Estimation Criteria","text":"begineqnarray\n      rho_m          = frac x - mu_m textrsc cdot sigma_mquad m in mathcalM m to x in mathcalX\nendeqnarray","category":"page"},{"location":"se_criteria/#","page":"State Estimation Criteria","title":"State Estimation Criteria","text":"where:","category":"page"},{"location":"se_criteria/#","page":"State Estimation Criteria","title":"State Estimation Criteria","text":"ρ denotes the residual associated with a measurement m,\nx denotes the variable corresponding to a measurement m.\nμ denotes the measured value, i.e., expectation 𝐄(X),\nσ denotes the the measurement error, i.e., standard deviation √(𝐕(X)),\nrsc denotes the rescaler.","category":"page"},{"location":"se_criteria/#","page":"State Estimation Criteria","title":"State Estimation Criteria","text":"Solving a state estimation using the WLAV criterion is non-trivial as the absolute value function is not continuously differentiable. This drawback is lifted by its exact linear relaxation: rWLAV[1]. The rWLAV criterion is given by","category":"page"},{"location":"se_criteria/#","page":"State Estimation Criteria","title":"State Estimation Criteria","text":"begineqnarray\n      rho_m          geq frac x_m - mu_m textrsc cdot sigma_mquad m in mathcalM m to x_m in mathcalX    \n      rho_m          geq - frac x_m - mu_m textrsc cdot sigma_mquad m in mathcalM m to x_m in mathcalX    \nendeqnarray","category":"page"},{"location":"se_criteria/#","page":"State Estimation Criteria","title":"State Estimation Criteria","text":"[1]: Note that this relaxation is only exact in the context of minimization problem.","category":"page"},{"location":"se_criteria/#WLS-and-rWLS-1","page":"State Estimation Criteria","title":"WLS and rWLS","text":"","category":"section"},{"location":"se_criteria/#","page":"State Estimation Criteria","title":"State Estimation Criteria","text":"The WLS criterion represents the Eucledian norm (p=2) and is given by","category":"page"},{"location":"se_criteria/#","page":"State Estimation Criteria","title":"State Estimation Criteria","text":"begineqnarray\n      rho_m          = frac( x_m - mu_m )^2textrsc cdot sigma_m^2quad m in mathcalM m_m to x in mathcalX\nendeqnarray","category":"page"},{"location":"se_criteria/#","page":"State Estimation Criteria","title":"State Estimation Criteria","text":"The rWLS criterion relaxes the former as a cone and is given by","category":"page"},{"location":"se_criteria/#","page":"State Estimation Criteria","title":"State Estimation Criteria","text":"begineqnarray\n      rsc cdot sigma_m^2 cdot rho_m geq ( x_m - mu_m )^2quad m in mathcalM m to x_m in mathcalX\nendeqnarray","category":"page"},{"location":"se_criteria/#Non-Gaussian-State-Estimation-Criteria-1","page":"State Estimation Criteria","title":"Non-Gaussian State Estimation Criteria","text":"","category":"section"},{"location":"se_criteria/#Gaussian-Mixture-Estimation-1","page":"State Estimation Criteria","title":"Gaussian Mixture Estimation","text":"","category":"section"},{"location":"se_criteria/#","page":"State Estimation Criteria","title":"State Estimation Criteria","text":"The Gaussian mixture criterion splits the random variable X into 𝓝 Gaussian  components Y, and introduces two constraints. First, the related variable x is the sum of the variables y related to the Gaussian components. Second, the  overall residual ρ equal to the sum of Gaussian components' residuals. The  rwlav criterion is choosen to model the residual of the Gaussian components.","category":"page"},{"location":"se_criteria/#","page":"State Estimation Criteria","title":"State Estimation Criteria","text":"begineqnarray\n      x_m             = sum_m to n in mathcalN w_n y_nquad m in mathcalM m to x_m in mathcalX                                  \n      rho_m          geq sum_m to n in mathcalN frac y_n - mu_n textrsc cdot w_n sigma_nquad m in mathcalM     \n      rho_m          geq - sum_m to n in mathcalN frac y_n - mu_n textrsc cdot w_n sigma_mquad m in mathcalM   \nendeqnarray","category":"page"},{"location":"se_criteria/#","page":"State Estimation Criteria","title":"State Estimation Criteria","text":"where:","category":"page"},{"location":"se_criteria/#","page":"State Estimation Criteria","title":"State Estimation Criteria","text":"w denotes the weight associated with a Gaussian component.","category":"page"},{"location":"se_criteria/#","page":"State Estimation Criteria","title":"State Estimation Criteria","text":"The user has to specify the number_of_gaussian through the se_settings (Input Data Format).  If no number is specified, it will default to 10.","category":"page"},{"location":"se_criteria/#Maximum-Likelihood-Estimation-1","page":"State Estimation Criteria","title":"Maximum Likelihood Estimation","text":"","category":"section"},{"location":"se_criteria/#","page":"State Estimation Criteria","title":"State Estimation Criteria","text":"The maximum likelihood criterion links the measurement residual to the logpdf of the associated distribution and is given by","category":"page"},{"location":"se_criteria/#","page":"State Estimation Criteria","title":"State Estimation Criteria","text":"begineqnarray\n      rho_m          = - textrsc cdot textlogpdf_m(x) + textshfquad m in mathcalM m to x in mathcalX\nendeqnarray","category":"page"},{"location":"se_criteria/#","page":"State Estimation Criteria","title":"State Estimation Criteria","text":"where shf denotes a shift setting the minimum value of the residual to zero.","category":"page"},{"location":"se_criteria/#","page":"State Estimation Criteria","title":"State Estimation Criteria","text":"To avoid the use of automatic differentiation, the first derivative (gradlogpdf) is provided by Distributions.jl and the second derivative (heslogpdf) is provided internally.","category":"page"}]
}
